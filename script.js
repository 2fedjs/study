/*#ссылки*/
//plnkr.co - для решения задач онлайн

////////////////////////////////////////////////////////////////

/*#подключение*/

/*<script src="/path/to/script.js"></script> - загрузка внешнего скрипта
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script> - загрузка внешнего скрипта
<script src="1.js" async></script> не будет мешать отображению документа, выполнится при загрузке, выполняются по мере загрузки
<script src="2.js" defer></script> - выполнится после загрузки документа, выполнятюся скрипты последовательно
<link rel=”preload” href=”external.js” as=”script”>*/

//Создать элемент и вставить на страницу
function addScript(src){ 

  var script = document.createElement('script'); 
  script.src = src; 
  script.async = false; // чтобы гарантировать порядок 
  document.head.appendChild(script); 

}

////////////////////////////////////////////////////////////////

/*#use strict*/

num = 5; // error: num is not defined

/*Function Declaration при use strict видны только внутри блока, в котором объявлены*/

function f(x) {
 "use strict"; // для браузеров с поддержкой строгого режима 
arguments[0] = 5; 
alert( x ); // не 5, а 1! Переменная "отвязана" от arguments 
} 
f(1);

/*У функций в режиме use strict вместо глобального объекта this будет undefined.

При use strict код внутри eval по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри eval, не попадут наружу.*/

// попытаемся записать свойство в строку:
var user = "Вася";
user.age = 30;
alert( user.age ); // undefined
/*Свойство age было записано во временный объект, который был тут же уничтожен, так что смысла в такой записи немного. Пример выше выполняется без use strict, в строгом режиме была бы ошибка, и это хорошо, так как такая запись, по большому счету, не имеет смысла.*/

////////////////////////////////////////////////////////////////

/*#типы данных*/

//Number:
Infinity, -Infinity , NaN

//String

//Boolean

//Null

//undefined

//object

//Оператор typeof возвращает тип аргумента.
typeof x
typeof(x)
//Результатом typeof является строка, содержащая тип

////////////////////////////////////////////////////////////////

/*#операторы*/

// Кроме плюса арифметические операторы работают только с числами и всегда приводят аргументы к числу.

alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа

//приоритет

/*20  Grouping  n/a ( … )
19          Member Access left-to-right … . …
  Computed Member Access  left-to-right … [ … ]
      new (with argument list)  n/a new … ( … )
            Function Call left-to-right … ( … )
18  new (without argument list) right-to-left new …
17  Postfix Increment n/a … ++
        Postfix Decrement … --
16  Logical NOT right-to-left ! …
                  Bitwise NOT ~ …
                  Unary Plus  + …
              Unary Negation  - …
            Prefix Increment  ++ …
            Prefix Decrement  -- …
                  typeof  typeof …
                      void  void …
                  delete  delete …
                    await await …
15  Exponentiation  right-to-left … ** …
14  Multiplication  left-to-right … * …
                        Division  … / …
                        Remainder … % …
13  Addition  left-to-right … + …
                Subtraction … - …
12  Bitwise Left Shift  left-to-right … << …
                  Bitwise Right Shift … >> …
        Bitwise Unsigned Right Shift  … >>> …
11  Less Than left-to-right … < …
        Less Than Or Equal  … <= …
              Greater Than  … > …
      Greater Than Or Equal … >= …
                        in  … in …
        instanceof  … instanceof …
10  Equality  left-to-right … == …
                Inequality  … != …
            Strict Equality … === …
          Strict Inequality … !== …
9 Bitwise AND left-to-right … & …
8 Bitwise XOR left-to-right … ^ …
7 Bitwise OR  left-to-right … | …
6 Logical AND left-to-right … && …
5 Logical OR  left-to-right … || …
4 Conditional right-to-left … ? … : …
3 Assignment  right-to-left … = …
                            … += …
                            … -= …
                            … **= …
                            … *= …
                            … /= …
                            … %= …
                            … <<= …
                            … >>= …
                            … >>>= …
                            … &= …
                            … ^= …
                            … |= …
2 yield right-to-left yield …
              yield*  yield* …
1 Comma / Sequence  left-to-right … , …*/


////////////////////////////////////////////////////////////////

/*#преобразование типов*/

alert( '2' > 1 ); // true, сравнивается как 2 > 1
alert( '01' == 1 ); // true, сравнивается как 1 == 1
alert( false == 0 ); // true, false становится числом 0
alert( true == 1 ); // true, так как true становится числом 1.

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
/*Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.
Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null или себе и ничему другому.*/

//Строковое преобразование
var a = true;
alert( a ); // "true"

String(null)

//Численное преобразование

//Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==).
var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект

//Значение  Преобразуется в...
undefined     NaN
null          0
true / false  1 / 0
/*Строка  Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.
Например:*/

 // после обрезания пробельных символов останется "123"
alert( +"   \n  123   \n  \n" ); // 123

//Логическое преобразование


//Значение  Преобразуется в...
undefined, null     false
//Числа Все true, кроме 0, NaN -- false.
//Строки  Все true, кроме пустой строки "" -- false
//Объекты Всегда true

//Для явного преобразования

!!value 
Boolean(value)

////////////////////////////////////////////////////////////////

/*#побитовые операции*/

/*операции

Побитовое И (AND) 
a & b Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
Побитовое ИЛИ (OR)  
a | b Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
Побитовое исключающее ИЛИ (XOR) 
a ^ b Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
Побитовое НЕ (NOT)  
~a  Заменяет каждый бит операнда на противоположный.
Левый сдвиг 
a << b  Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
Правый сдвиг, переносящий знак  
a >> b  Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг с заполнением нулями 
a >>> b Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.*/

parseInt("11000", 2) //переводит строку с двоичной записью числа в число.
n.toString(2) //получает для числа n запись в 2-ной системе в виде строки.

//& (Побитовое И)
/*a b a & b
0 0   0
0 1   0
1 0   0
1 1   1*/

//| (Побитовое ИЛИ)
/*a b a | b
0 0   0
0 1   1
1 0   1
1 1   1*/

//^ (Исключающее ИЛИ)
/*a b a ^ b
0 0   0
0 1   1
1 0   1
1 1   0*/

//~ (Побитовое НЕ)

 9 //(по осн. 10)
  = 00000000000000000000000000001001 //(по осн. 2)
             //  --------------------------------
~9 //(по осн. 10)
  = 11111111111111111111111111110110 //(по осн. 2)
  = -10 //(по осн. 10)
//Из-за внутреннего представления отрицательных чисел получается так, что ~n == -(n+1).
alert( ~3 ); // -4
alert( ~-1 ); // 0

//<< (Битовый сдвиг влево)

9 //(по осн.10)
  = 00000000000000000000000000001001 //(по осн.2)
               //   --------------------------------
9 << 2 //(по осн.10)
  = 00000000000000000000000000100100 //(по осн.2)
  = 36 //(по осн.10)

  //побитовые операторы работают только с 32-битными числами

  alert(10000000000 << 1); // -1474836480, отброшен крайний-левый бит
  alert(10000000000 * 2); // 20000000000, обычное умножение

 // >> (Правый битовый сдвиг, переносящий знак)

9 //(по осн.10)
  = 00000000000000000000000000001001 //(по осн.2)
          //       --------------------------------
9 >> 2 //(по осн.10)
  = 00000000000000000000000000000010 //(по осн.2)
  = 2 //(по осн.10)

//  >>> (Правый сдвиг с заполнением нулями)
/*Для неотрицательных чисел правый сдвиг с заполнением нулями >>> и правый сдвиг с переносом знака >> дадут одинаковый результат, т.к в обоих случаях слева добавятся нули.
Для отрицательных чисел – результат работы разный. Например, -9 >>> 2 даст 1073741821, в отличие от -9 >> 2 (дает -3):*/
-9 //(по осн.10)
  = 11111111111111111111111111110111 //(по осн.2)
              //      --------------------------------
-9 >>> 2 //(по осн.10)
  = 00111111111111111111111111111101 //(по осн.2)
  = 1073741821 //(по осн.10)

//Пример
  // найти пользователей с правами на изменение товаров или администраторов
findUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);


var str = "Проверка";

if (~str.indexOf("верка")) { // Сочетание "if (~...indexOf)" читается как "если найдено"
  alert( 'найдено!' );
}

////////////////////////////////////////////////////////////////

/*#взаимодействие с пользователем*/

var years = prompt('Сколько вам лет?', 100);
//Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.

var isAdmin = confirm("Вы - администратор?");
//Результатом будет true при нажатии OK и false – при CANCEL(Esc).

////////////////////////////////////////////////////////////////

/*#операторы*/

//Для if Число 0, пустая строка "", null и undefined, а также NaN являются false,

//В частности, двойное НЕ используют для преобразования значений к логическому типу:

 alert( !!"строка" ); // true
alert( !!null ); // false

//switch 

var a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( 'Я таких значений не знаю' );
}


////////////////////////////////////////////////////////////////

/*#циклы*/

var i = 0;
while (i < 3) {
  alert( i );
  i++;
}

var i = 0;
do {
  alert( i );
  i++;
} while (i < 3);

var i;
for (i = 0; i < 3; i++) {
  alert( i );
}

//Прерывание цикла: break

var sum = 0;
while (true) {
  var value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );

//Следующая итерация: continue

/*Директива continue прекращает выполнение текущей итерации цикла.
Она – в некотором роде «младшая сестра» директивы break: прерывает не весь цикл, а только текущее выполнение его тела, как будто оно закончилось.
Её используют, если понятно, что на текущем повторе цикла делать больше нечего.*/
//Например, цикл ниже использует continue, чтобы не выводить чётные значения:

for (var i = 0; i < 10; i++) {
  if (i % 2 == 0) continue;
  alert(i);
}

//Метки для break/continue

//Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    var input = prompt('Значение в координатах '+i+','+j, '');
    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // (*)
  }
}
alert('Готово!');

//Метка имеет вид "имя:", имя должно быть уникальным. Она ставится перед циклом, вот так:

outer: for (var i = 0; i < 3; i++) { ... }

//Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец.

////////////////////////////////////////////////////////////////

/*#функции*/

//Function Expression

var sayHi = function(person) {
  alert( "Привет, " + person );
};

sayHi('Вася');

//Function Declaration

function sum(a, b) {
  return a + b;
}

//функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

// создавать функцию полностью «на лету» из строки, вот так:
var sum = new Function('a,b', ' return a+b; ');

//Named Function Expression
var f = function sayHi(name) {
  alert( sayHi ); // изнутри функции - видно (выведет код функции)
};

alert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')
//Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.
//Попробуем перенести её в другую переменную g:
function f(n) {
  return n ? n * f(n - 1) : 1;
};

var g = f;
f = null;

alert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!

//Для того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:
 var f = function factorial(n) {
  return n ? n*factorial(n-1) : 1;
};

var g = f;  // скопировали ссылку на функцию-факториал в g
f = null;

alert( g(5) ); // 120, работает!

////////////////////////////////////////////////////////////////

/*#тесты*/

/*Пример HTML-страницы для тестов:

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <!-- подключаем стили Mocha, для отображения результатов -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">
  <!-- подключаем библиотеку Mocha -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"></script>
  <!-- настраиваем Mocha: предстоит BDD-тестирование -->
  <script>
    mocha.setup('bdd');
  </script>

  <!-- подключаем chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"></script>
  <!-- в chai есть много всего, выносим assert в глобальную область -->
  <script>
    var assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      // код функции, пока что пусто 
    }
  </script>

  <!-- в этом скрипте находятся спеки -->
  <script src="test.js"></script>

  <!-- в элементе с id="mocha" будут результаты тестов -->
  <div id="mocha"></div>

  <!-- запустить тесты! -->
  <script>
    mocha.run();
  </script>
</body>

</html>*/

//Исправление спецификации

//Первый вариант – добавить assert в тот же it:

describe("pow", function() {

  it("возводит в n-ю степень", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
//Второй вариант – сделать два теста:

describe("pow", function() {

  it("при возведении 2 в 3ю степень результат 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("при возведении 3 в 4ю степень равен 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});

//Уточнение реализации
//Придётся написать нечто более реальное, чтобы тесты проходили:

function pow(x, n) {
  var result = 1;

  for (var i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
//Чтобы быть уверенными, что функция работает верно, желательно протестировать её на большем количестве значений. Вместо того, чтобы писать блоки it вручную, мы можем сгенерировать тесты в цикле for:

describe("pow", function() {

  function makeTest(x) {
    var expected = x * x * x;
    it("при возведении " + x + " в степень 3 результат: " + expected, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (var x = 1; x <= 5; x++) {
    makeTest(x);
  }

});

//Вложенный describe
//Функция makeTest и цикл for, очевидно, нужны друг другу, но не нужны для других тестов, которые мы добавим в дальнейшем. Они образуют единую группу, задача которой – проверить возведение в n-ю степень.

//Будет правильно выделить их, при помощи вложенного блока describe:
describe("pow", function() {

  describe("возводит x в степень n", function() {

    function makeTest(x) {
      var expected = x * x * x;
      it("при возведении " + x + " в степень 3 результат: " + expected, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (var x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... дальнейшие тесты it и подблоки describe ...
});

//before/after и beforeEach/afterEach
//В каждом блоке describe можно также задать функции before/after, которые будут выполнены до/после запуска тестов, а также beforeEach/afterEach, которые выполняются до/после каждого it.

//Например:

describe("Тест", function() {

  before(function() { alert("Начало тестов"); });
  after(function() { alert("Конец тестов"); });

  beforeEach(function() { alert("Вход в тест"); });
  afterEach(function() { alert("Выход из теста"); });

  it('тест 1', function() { alert('1'); });
  it('тест 2', function() { alert('2'); });

});

//Расширение спецификации

describe("pow", function() {

  // ...

  it("при возведении в отрицательную степень результат NaN", function() {
    assert(isNaN(pow(2, -1)));
  });

  it("при возведении в дробную степень результат NaN", function() {
    assert(isNaN(pow(2, 1.5)));
  });

});

/*самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false*/

//Все вызовы assert позволяют дополнительным последним аргументом указать строку с описанием ошибки, которое выводится, если assert не проходит.

//Добавим описание ошибки в конец наших assert'ов:
describe("pow", function() {

  // ...

  it("при возведении в отрицательную степень результат NaN", function() {
    assert(isNaN(pow(2, -1)), "pow(2, -1) не NaN");
  });

  it("при возведении в дробную степень результат NaN", function() {
    assert(isNaN(pow(2, 1.5)), "pow(2, 1.5) не NaN");
  });

});