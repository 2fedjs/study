/*#ссылки*/

//plnkr.co - для решения задач онлайн

////////////////////////////////////////////////////////////////

/*#подключение*/

/*<script src="/path/to/script.js"></script> - загрузка внешнего скрипта
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script> - загрузка внешнего скрипта
<script src="1.js" async></script> не будет мешать отображению документа, выполнится при загрузке, выполняются по мере загрузки
<script src="2.js" defer></script> - выполнится после загрузки документа, выполнятюся скрипты последовательно
<link rel=”preload” href=”external.js” as=”script”>*/

//Создать элемент и вставить на страницу
function addScript(src){ 

  var script = document.createElement('script'); 
  script.src = src; 
  script.async = false; // чтобы гарантировать порядок 
  document.head.appendChild(script); 

}

////////////////////////////////////////////////////////////////

/*#use strict*/

num = 5; // error: num is not defined

/*Function Declaration при use strict видны только внутри блока, в котором объявлены*/

function f(x) {
 "use strict"; // для браузеров с поддержкой строгого режима 
arguments[0] = 5; 
alert( x ); // не 5, а 1! Переменная "отвязана" от arguments 
} 
f(1);

/*У функций в режиме use strict вместо глобального объекта this будет undefined.

При use strict код внутри eval по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри eval, не попадут наружу.*/

// попытаемся записать свойство в строку:
var user = "Вася";
user.age = 30;
alert( user.age ); // undefined
/*Свойство age было записано во временный объект, который был тут же уничтожен, так что смысла в такой записи немного. Пример выше выполняется без use strict, в строгом режиме была бы ошибка, и это хорошо, так как такая запись, по большому счету, не имеет смысла.*/

////////////////////////////////////////////////////////////////

/*#типы данных*/

//Number:
Infinity, -Infinity , NaN

//String

//Boolean

//Null

//undefined

//object

//Оператор typeof возвращает тип аргумента.
typeof x
typeof(x)
//Результатом typeof является строка, содержащая тип

////////////////////////////////////////////////////////////////

/*#строки*/

alert( "Привет, мир!".length ); // 12
alert( hello.toUpperCase() ); // "ПРИВЕТ, МИР!"
alert( "Интерфейс" [0].toLowerCase() ); // 'и'

var str = "jQuery";
alert( str.charAt(0) ); // "j"

var str = "Я - современный браузер!";
alert( str[0] ); // "Я"

//charAt выдает пустую строку, а скобки – undefined:

var str = "Widget with id";
alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
alert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр
alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

var str = "stringify";
alert(str.slice(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.

alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.
alert( "testme".substring(-2) ); // "testme", -2 становится 0
//если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
alert( "testme".substring(4, -1) ); // "test"
// -1 становится 0 -> получили substring(4, 0)
// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
alert(str.substring(2)); // ringify, символы с позиции 2 до конца

str = str.substr(2,4); // ring, со 2-й позиции 4 символа
//Если параметр start является отрицательным, метод substr() использует его как индекс символа, начиная с конца строки. Если параметр start отрицателен и по модулю больше длины строки, метод substr() будет использовать 0 в качестве начального индекса.

alert( String.fromCharCode(1072) ); // 'а'
alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'

var str = "Ёлки";
alert( str.localeCompare("Яблони") ); // -1
//Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.

/*Специальные символы
Символ  Описание
\b      Backspace
\f      Form feed
\n      New line
\r      Carriage return
\t      Tab
\uNNNN  Символ в кодировке Юникод с шестнадцатеричным кодом `NNNN`. Например, `\u00A9` -- юникодное представление символа копирайт ©*/

////////////////////////////////////////////////////////////////

/*#числа*/

//Округляет число num до n знаков после запятой
alert( n.toFixed(2) ); // "12.35"
alert( n.toFixed(0) ); // "12"
alert( n.toFixed(5) ); // "12.34500"

alert( 0xFF ); // 255 в шестнадцатиричной системе

isNaN(n)

//точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity
isNumeric(n)

//Проверка на три специальных числовых значения: NaN, Infinity и -Infinity.
alert( isFinite(1) ); // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) ); // false

alert( parseInt('12px') ); // 12
alert( parseInt('FF', 16) ); // 255

alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке

alert( n.toString(16) ); // ff
var n = 1234567890;
alert( n.toString(36) ); // kf12oi

alert( number.toLocaleString() ); // 123 456 789

////////////////////////////////////////////////////////////////

/*#объекты*/

//Создание объектов
o = new Object(); // (1)
o = {}; // пустые фигурные скобки (2)

//проверить, есть ли в объекте свойство с определенным ключом.
if ("name" in person) //причем имя свойства – в виде строки

//Для перебора всех свойств из объекта
for (var key in menu) {
  alert( "Ключ: " + key + " значение: " + menu[key] );
}

// работать со свойствами в виде массива
var user = {
  name: "Петя",
  age: 30
}
var keys = Object.keys(user);
alert( keys ); // name, age

////////////////////////////////////////////////////////////////

/*#массивы*/

//Метод pop
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удалили "Груша"
alert( fruits ); // Яблоко, Апельсин

//Метод push
var fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша"); //могут добавлять сразу по несколько элементов: fruits.push("Апельсин", "Персик");
alert( fruits ); // Яблоко, Апельсин, Груша

//Метод shift
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удалили Яблоко
alert( fruits ); // Апельсин, Груша

//Метод unshift
var fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');//могут добавлять сразу по несколько элементов: fruits.unshift("Ананас", "Лимон");
alert( fruits ); // Яблоко, Апельсин, Груша

//Существует еще один синтаксис для создания массива:
var arr = new Array("Яблоко", "Груша", "и т.п.");

//Операции с массивами также оптимизируются, особенно если массив хранит только один тип данных, например только числа. Порождаемый набор инструкций для процессора получается очень эффективным.

//Метод split
//превратить строку в массив
var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ');
//необязательный второй аргумент – ограничение на количество элементов в массиве
alert( "a,b,c,d".split(',', 2) ); // a,b

var str = "тест";
alert( str.split('') ); // т,е,с,т

//Метод join
// массив склеить в строку
var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert( str ); // Маша;Петя;Марина;Василий
//Код для повторения строки 3 раза:
 alert( new Array(4).join("ля") ); // ляляля

//Метод splice
 arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
 // удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")
//splice возвращает массив из удаленных элементов

// с позиции 2
// удалить 0
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

// начиная с позиции индексом -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

//Метод slice
//Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert( arr2 ); // надо, учить

var arr = ["Почему", "надо", "учить", "JavaScript"];
alert( arr.slice(1) ); // взять все элементы, начиная с номера 1

var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше

//Если вообще не указать аргументов – скопируется весь массив:
var fullCopy = arr.slice();

//Метод sort
//Метод sort() сортирует массив на месте. Например:
 var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2

function compareNumeric(a, b) { // return a - b;
  if (a > b) return 1;
  if (a < b) return -1;
}
var arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15

//Метод reverse
var arr = [1, 2, 3];
arr.reverse();
alert( arr ); // 3,2,1

//Метод concat
//создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN

var arr = [1, 2];
var newArr = arr.concat(3, 4);
alert( newArr ); // 1,2,3,4

//метод indexOf/lastIndexOf
//Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.
var arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

//Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.

////////////////////////////////////////////////////////////////

/*#Math*/

alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3 , до ближайшего целого

Math.acos(x)
//Возвращает арккосинус x (в радианах)
Math.asin(x)
//Возвращает арксинус x (в радианах)
Math.atan(x)
//Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
//Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
//Вычисляет синус x
Math.cos(x)
//Вычисляет косинус x
Math.tan(x)
//Возвращает тангенс x
Math.sqrt(x)
//Возвращает квадратный корень из x.
Math.log(x)
//Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
//Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
//Возвращает абсолютное значение числа
Math.exp(x)
//Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)
//Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
//Возвращает наименьший из списка аргументов
Math.random()
//Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.

////////////////////////////////////////////////////////////////

/*#операторы*/

// Кроме плюса арифметические операторы работают только с числами и всегда приводят аргументы к числу.

alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа

//приоритет

/*20  Grouping  n/a ( … )
19          Member Access left-to-right … . …
  Computed Member Access  left-to-right … [ … ]
      new (with argument list)  n/a new … ( … )
            Function Call left-to-right … ( … )
18  new (without argument list) right-to-left new …
17  Postfix Increment n/a … ++
        Postfix Decrement … --
16  Logical NOT right-to-left ! …
                  Bitwise NOT ~ …
                  Unary Plus  + …
              Unary Negation  - …
            Prefix Increment  ++ …
            Prefix Decrement  -- …
                  typeof  typeof …
                      void  void …
                  delete  delete …
                    await await …
15  Exponentiation  right-to-left … ** …
14  Multiplication  left-to-right … * …
                        Division  … / …
                        Remainder … % …
13  Addition  left-to-right … + …
                Subtraction … - …
12  Bitwise Left Shift  left-to-right … << …
                  Bitwise Right Shift … >> …
        Bitwise Unsigned Right Shift  … >>> …
11  Less Than left-to-right … < …
        Less Than Or Equal  … <= …
              Greater Than  … > …
      Greater Than Or Equal … >= …
                        in  … in …
        instanceof  … instanceof …
10  Equality  left-to-right … == …
                Inequality  … != …
            Strict Equality … === …
          Strict Inequality … !== …
9 Bitwise AND left-to-right … & …
8 Bitwise XOR left-to-right … ^ …
7 Bitwise OR  left-to-right … | …
6 Logical AND left-to-right … && …
5 Logical OR  left-to-right … || …
4 Conditional right-to-left … ? … : …
3 Assignment  right-to-left … = …
                            … += …
                            … -= …
                            … **= …
                            … *= …
                            … /= …
                            … %= …
                            … <<= …
                            … >>= …
                            … >>>= …
                            … &= …
                            … ^= …
                            … |= …
2 yield right-to-left yield …
              yield*  yield* …
1 Comma / Sequence  left-to-right … , …*/

//Для if Число 0, пустая строка "", null и undefined, а также NaN являются false,

//В частности, двойное НЕ используют для преобразования значений к логическому типу:

 alert( !!"строка" ); // true
alert( !!null ); // false

//switch 

var a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( 'Я таких значений не знаю' );
}




////////////////////////////////////////////////////////////////

/*#преобразование типов*/

alert( '2' > 1 ); // true, сравнивается как 2 > 1
alert( '01' == 1 ); // true, сравнивается как 1 == 1
alert( false == 0 ); // true, false становится числом 0
alert( true == 1 ); // true, так как true становится числом 1.

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
/*Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.
Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null или себе и ничему другому.*/

//Строковое преобразование
var a = true;
alert( a ); // "true"

String(null)

//Численное преобразование

//Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==).
var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект

//Значение  Преобразуется в...
undefined     NaN
null          0
true / false  1 / 0
/*Строка  Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.
Например:*/

 // после обрезания пробельных символов останется "123"
alert( +"   \n  123   \n  \n" ); // 123

//Логическое преобразование


//Значение  Преобразуется в...
undefined, null     false
//Числа Все true, кроме 0, NaN -- false.
//Строки  Все true, кроме пустой строки "" -- false
//Объекты Всегда true

//Для явного преобразования

!!value 
Boolean(value)

////////////////////////////////////////////////////////////////

/*#побитовые операции*/

/*операции

Побитовое И (AND) 
a & b Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
Побитовое ИЛИ (OR)  
a | b Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
Побитовое исключающее ИЛИ (XOR) 
a ^ b Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
Побитовое НЕ (NOT)  
~a  Заменяет каждый бит операнда на противоположный.
Левый сдвиг 
a << b  Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
Правый сдвиг, переносящий знак  
a >> b  Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг с заполнением нулями 
a >>> b Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.*/

parseInt("11000", 2) //переводит строку с двоичной записью числа в число.

n.toString(2) //получает для числа n запись в 2-ной системе в виде строки.

//& (Побитовое И)
/*a b a & b
0 0   0
0 1   0
1 0   0
1 1   1*/

//| (Побитовое ИЛИ)
/*a b a | b
0 0   0
0 1   1
1 0   1
1 1   1*/

//^ (Исключающее ИЛИ)
/*a b a ^ b
0 0   0
0 1   1
1 0   1
1 1   0*/

//~ (Побитовое НЕ)

 9 //(по осн. 10)
  = 00000000000000000000000000001001 //(по осн. 2)
             //  --------------------------------
~9 //(по осн. 10)
  = 11111111111111111111111111110110 //(по осн. 2)
  = -10 //(по осн. 10)
//Из-за внутреннего представления отрицательных чисел получается так, что ~n == -(n+1).
alert( ~3 ); // -4
alert( ~-1 ); // 0

//<< (Битовый сдвиг влево)

9 //(по осн.10)
  = 00000000000000000000000000001001 //(по осн.2)
               //   --------------------------------
9 << 2 //(по осн.10)
  = 00000000000000000000000000100100 //(по осн.2)
  = 36 //(по осн.10)

  //побитовые операторы работают только с 32-битными числами

  alert(10000000000 << 1); // -1474836480, отброшен крайний-левый бит
  alert(10000000000 * 2); // 20000000000, обычное умножение

 // >> (Правый битовый сдвиг, переносящий знак)

9 //(по осн.10)
  = 00000000000000000000000000001001 //(по осн.2)
          //       --------------------------------
9 >> 2 //(по осн.10)
  = 00000000000000000000000000000010 //(по осн.2)
  = 2 //(по осн.10)

//  >>> (Правый сдвиг с заполнением нулями)
/*Для неотрицательных чисел правый сдвиг с заполнением нулями >>> и правый сдвиг с переносом знака >> дадут одинаковый результат, т.к в обоих случаях слева добавятся нули.
Для отрицательных чисел – результат работы разный. Например, -9 >>> 2 даст 1073741821, в отличие от -9 >> 2 (дает -3):*/
-9 //(по осн.10)
  = 11111111111111111111111111110111 //(по осн.2)
              //      --------------------------------
-9 >>> 2 //(по осн.10)
  = 00111111111111111111111111111101 //(по осн.2)
  = 1073741821 //(по осн.10)

//Пример
  // найти пользователей с правами на изменение товаров или администраторов
findUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);


var str = "Проверка";

if (~str.indexOf("верка")) { // Сочетание "if (~...indexOf)" читается как "если найдено"
  alert( 'найдено!' );
}

////////////////////////////////////////////////////////////////

/*#циклы*/

var i = 0;
while (i < 3) {
  alert( i );
  i++;
}

var i = 0;
do {
  alert( i );
  i++;
} while (i < 3);

var i;
for (i = 0; i < 3; i++) {
  alert( i );
}

//Прерывание цикла: break

var sum = 0;
while (true) {
  var value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );

//Следующая итерация: continue

/*Директива continue прекращает выполнение текущей итерации цикла.
Она – в некотором роде «младшая сестра» директивы break: прерывает не весь цикл, а только текущее выполнение его тела, как будто оно закончилось.
Её используют, если понятно, что на текущем повторе цикла делать больше нечего.*/
//Например, цикл ниже использует continue, чтобы не выводить чётные значения:

for (var i = 0; i < 10; i++) {
  if (i % 2 == 0) continue;
  alert(i);
}

//Метки для break/continue

//Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    var input = prompt('Значение в координатах '+i+','+j, '');
    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // (*)
  }
}
alert('Готово!');

//Метка имеет вид "имя:", имя должно быть уникальным. Она ставится перед циклом, вот так:

outer: for (var i = 0; i < 3; i++) { ... }

//Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец.

////////////////////////////////////////////////////////////////

/*#функции*/

//Встроенные функции
var years = prompt('Сколько вам лет?', 100);
//Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.

var isAdmin = confirm("Вы - администратор?");
//Результатом будет true при нажатии OK и false – при CANCEL(Esc).

//Function Expression

var sayHi = function(person) {
  alert( "Привет, " + person );
};

sayHi('Вася');

//Function Declaration

function sum(a, b) {
  return a + b;
}

//функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

// создавать функцию полностью «на лету» из строки, вот так:
var sum = new Function('a,b', ' return a+b; ');

//Named Function Expression
var f = function sayHi(name) {
  alert( sayHi ); // изнутри функции - видно (выведет код функции)
};

alert( sayHi ); // снаружи - не видно (ошибка: undefined variable 'sayHi')
//Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.
//Попробуем перенести её в другую переменную g:
function f(n) {
  return n ? n * f(n - 1) : 1;
};

var g = f;
f = null;

alert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!

//Для того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:
 var f = function factorial(n) {
  return n ? n*factorial(n-1) : 1;
};

var g = f;  // скопировали ссылку на функцию-факториал в g
f = null;

alert( g(5) ); // 120, работает!

////////////////////////////////////////////////////////////////

/*#тесты*/

/*Пример HTML-страницы для тестов:

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <!-- подключаем стили Mocha, для отображения результатов -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.css">
  <!-- подключаем библиотеку Mocha -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/2.1.0/mocha.js"></script>
  <!-- настраиваем Mocha: предстоит BDD-тестирование -->
  <script>
    mocha.setup('bdd');
  </script>

  <!-- подключаем chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/2.0.0/chai.js"></script>
  <!-- в chai есть много всего, выносим assert в глобальную область -->
  <script>
    var assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      // код функции, пока что пусто 
    }
  </script>

  <!-- в этом скрипте находятся спеки -->
  <script src="test.js"></script>

  <!-- в элементе с id="mocha" будут результаты тестов -->
  <div id="mocha"></div>

  <!-- запустить тесты! -->
  <script>
    mocha.run();
  </script>
</body>

</html>*/

//Исправление спецификации

//Первый вариант – добавить assert в тот же it:

describe("pow", function() {

  it("возводит в n-ю степень", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
//Второй вариант – сделать два теста:

describe("pow", function() {

  it("при возведении 2 в 3ю степень результат 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("при возведении 3 в 4ю степень равен 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});

//Уточнение реализации
//Придётся написать нечто более реальное, чтобы тесты проходили:

function pow(x, n) {
  var result = 1;

  for (var i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
//Чтобы быть уверенными, что функция работает верно, желательно протестировать её на большем количестве значений. Вместо того, чтобы писать блоки it вручную, мы можем сгенерировать тесты в цикле for:

describe("pow", function() {

  function makeTest(x) {
    var expected = x * x * x;
    it("при возведении " + x + " в степень 3 результат: " + expected, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (var x = 1; x <= 5; x++) {
    makeTest(x);
  }

});

//Вложенный describe
//Функция makeTest и цикл for, очевидно, нужны друг другу, но не нужны для других тестов, которые мы добавим в дальнейшем. Они образуют единую группу, задача которой – проверить возведение в n-ю степень.

//Будет правильно выделить их, при помощи вложенного блока describe:
describe("pow", function() {

  describe("возводит x в степень n", function() {

    function makeTest(x) {
      var expected = x * x * x;
      it("при возведении " + x + " в степень 3 результат: " + expected, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (var x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... дальнейшие тесты it и подблоки describe ...
});

//before/after и beforeEach/afterEach
//В каждом блоке describe можно также задать функции before/after, которые будут выполнены до/после запуска тестов, а также beforeEach/afterEach, которые выполняются до/после каждого it.

//Например:

describe("Тест", function() {

  before(function() { alert("Начало тестов"); });
  after(function() { alert("Конец тестов"); });

  beforeEach(function() { alert("Вход в тест"); });
  afterEach(function() { alert("Выход из теста"); });

  it('тест 1', function() { alert('1'); });
  it('тест 2', function() { alert('2'); });

});

//Расширение спецификации

describe("pow", function() {

  // ...

  it("при возведении в отрицательную степень результат NaN", function() {
    assert(isNaN(pow(2, -1)));
  });

  it("при возведении в дробную степень результат NaN", function() {
    assert(isNaN(pow(2, 1.5)));
  });

});

/*самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false*/

//Все вызовы assert позволяют дополнительным последним аргументом указать строку с описанием ошибки, которое выводится, если assert не проходит.

//Добавим описание ошибки в конец наших assert'ов:
describe("pow", function() {

  // ...

  it("при возведении в отрицательную степень результат NaN", function() {
    assert(isNaN(pow(2, -1)), "pow(2, -1) не NaN");
  });

  it("при возведении в дробную степень результат NaN", function() {
    assert(isNaN(pow(2, 1.5)), "pow(2, 1.5) не NaN");
  });

});