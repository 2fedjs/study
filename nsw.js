#1*/

/*Первым выполнится big.js, это нормальная последовательность выполнения подряд идущих скриптов.
Первым выполнится small.js, так как скрипты из-за async ведут себя совершенно независимо друг от друга, страница тоже от них не зависит.
Первым выполнится big.js, так как скрипты, подключённые через defer, сохраняют порядок выполнения относительно друг друга.*/

////////////////////////////////////////////////////////////////

/*#2*/

var a = 1, b = 1, c, d;

// префиксная форма сначала увеличивает a до 2, а потом возвращает
c = ++a; alert(c); // 2

// постфиксная форма увеличивает, но возвращает старое значение
d = b++; alert(d); // 1

// сначала увеличили a до 3, потом использовали в арифметике
c = (2+ ++a); alert(c); // 5

// увеличили b до 3, но в этом выражении оставили старое значение
d = (2+ b++); alert(d); // 4

// каждую переменную увеличили по 2 раза
alert(a); // 3
alert(b); // 3

////////////////////////////////////////////////////////////////

/*#3*/

//Ответ: x = 5.

//Оператор присваивания возвращает значение, которое будет записано в переменную, например:

 var a = 2;
alert( a *= 2 ); // 4
//Отсюда x = 1 + 4 = 5.

////////////////////////////////////////////////////////////////

/*#4*/

/*1. Операция a^b ставит бит результата в 1, если на соответствующей битовой позиции в a или b (но не одновременно) стоит 1.

Так как в 0 везде стоят нули, то биты берутся в точности как во втором аргументе.

2. Первое побитовое НЕ ~ превращает 0 в 1, а 1 в 0. А второе НЕ превращает ещё раз, в итоге получается как было.*/

////////////////////////////////////////////////////////////////

/*#5*/

//Один из вариантов такой функции:

 function isInteger(num) {
  return (num ^ 0) === num;
}

alert( isInteger(1) ); // true
alert( isInteger(1.5) ); // false
alert( isInteger(-0.5) ); // false
//Обратите внимание: num^0 – в скобках! Это потому, что приоритет операции ^ очень низкий. Если не поставить скобку, то === сработает раньше. Получится num ^ (0 === num), а это уже совсем другое дело.

////////////////////////////////////////////////////////////////

/*#6*/

/*Операция над числами, в конечном итоге, сводится к битам.

Посмотрим, можно ли поменять местами биты слева и справа.

Например, таблица истинности для ^:

a	b	результат
0	0	0
0	1	1
1	0	1
1	1	0
Случаи 0^0 и 1^1 заведомо не изменятся при перемене мест, поэтому нас не интересуют. А вот 0^1 и 1^0 эквивалентны и равны 1.

Аналогично можно увидеть, что и другие операторы симметричны.

Ответ: да.*/

////////////////////////////////////////////////////////////////

/*#7*/

/*Всё дело в том, что побитовые операции преобразуют число в 32-битное целое.

Обычно число в JavaScript имеет 64-битный формат с плавающей точкой. При этом часть битов (52) отведены под цифры, часть (11) отведены под хранение номера позиции, на которой стоит десятичная точка, и один бит – знак числа.

Это означает, что максимальное целое число, которое можно хранить, занимает 52 бита.

Число 12345678912345 в двоичном виде: 10110011101001110011110011100101101101011001 (44 цифры).

Побитовый оператор ^ преобразует его в 32-битное путём отбрасывания десятичной точки и «лишних» старших цифр. При этом, так как число большое и старшие биты здесь ненулевые, то, естественно, оно изменится.

Вот ещё пример:*/

 // в двоичном виде 1000000000000000000000000000000 (31 цифры)
alert( Math.pow(2, 30) ); // 1073741824
alert( Math.pow(2, 30) ^ 0 ); // 1073741824, всё ок, длины хватает

// в двоичном виде 100000000000000000000000000000000 (33 цифры)
alert( Math.pow(2, 32) ); // 4294967296
alert( Math.pow(2, 32) ^ 0 ); // 0, отброшены старшие цифры, остались нули

// пограничный случай
// в двоичном виде 10000000000000000000000000000000 (32 цифры)
alert( Math.pow(2, 31) ); // 2147483648
alert( Math.pow(2, 31) ^ 0 ); // -2147483648, ничего не отброшено,
// но первый бит 1 теперь стоит в начале числа и является знаковым

////////////////////////////////////////////////////////////////

/*#8*/

/*Да, выведется, т.к. внутри if стоит строка "0".

Любая строка, кроме пустой (а здесь она не пустая), в логическом контексте является true.

Можно запустить и проверить:
*/
 if ("0") {
  alert( 'Привет' );
}

////////////////////////////////////////////////////////////////

/*#9*/

var value = prompt('Введите число', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}

////////////////////////////////////////////////////////////////

/*#10*/

result = (a + b < 4) ? 'Мало' : 'Много';

////////////////////////////////////////////////////////////////

/*#11*/

var message = (login == 'Вася') ? 'Привет' :
  (login == 'Директор') ? 'Здравствуйте' :
  (login == '') ? 'Нет логина' :
  '';

////////////////////////////////////////////////////////////////

/*#12*/

//Ответ: 2, это первое значение, которое в логическом контексте даст true.

 alert( null || 2 || undefined );

////////////////////////////////////////////////////////////////

/*#13*/

//Ответ: сначала 1, затем 2.

 alert( alert(1) || 2 || alert(3) );
//Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

//Первый оператор ИЛИ || выполнит первый alert(1), получит undefined и пойдёт дальше, ко второму операнду.
//Так как второй операнд 2 является истинным, то вычисления завершатся, результатом undefined || 2 будет 2, которое будет выведено внешним alert( .... ).
//Второй оператор || не будет выполнен, выполнение до alert(3) не дойдёт, поэтому 3 выведено не будет.

////////////////////////////////////////////////////////////////

/*#14*/

//Ответ: null, это первое ложное значение из списка.

 alert( 1 && null && 2 );

////////////////////////////////////////////////////////////////

/*#15*/

//Ответ: 1, а затем undefined.

 alert( alert(1) && alert(2) );
//Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

//Поэтому до правого alert дело не дойдёт, вычисления закончатся на левом.

////////////////////////////////////////////////////////////////

/*#16*/

//Ответ: 3.

 alert( null || 2 && 3 || 4 );
//Приоритет оператора && выше, чем ||, поэтому он выполнится первым.

//Последовательность вычислений:

null || 2 && 3 || 4
null || 3 || 4
3

////////////////////////////////////////////////////////////////

/*#17*/

if (age >= 14 && age <= 90)

////////////////////////////////////////////////////////////////

/*#18*/

//Первый вариант:

if (!(age >= 14 && age <= 90))
//Второй вариант:

if (age < 14 || age > 90)

////////////////////////////////////////////////////////////////

/*#19*/

/*Ответ: первое и третье выполнятся.

Детали:*/

 // Выполнится
// Результат -1 || 0 = -1, в логическом контексте true
if (-1 || 0) alert( 'первое' );

// Не выполнится
// -1 && 0 = 0,  в логическом контексте false
if (-1 && 0) alert( 'второе' );

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1 -> null || 1 -> 1
if (null || -1 && 1) alert( 'третье' );

////////////////////////////////////////////////////////////////

/*#20*/

"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5
 = "$45"
"4" - 2
 = 2
"4px" - 2
 = NaN
7 / 0
 = Infinity
" -9\n" + 5 = " -9\n5"
" -9\n" - 5 = -14
5 && 2
 = 2
2 && 5
 = 5
5 || 0
 = 5
0 || 5 = 5
null + 1 = 1 // (3)
undefined + 1 = NaN // (4)
null == "\n0\n" = false // (5)
+null == +"\n0\n" = true // (6)
/*1. Оператор "+" в данном случае прибавляет 1 как строку, и затем 0.
2. Оператор "-" работает только с числами, так что он сразу приводит "" к 0.
3. null при численном преобразовании становится 0
4. undefined при численном преобразовании становится NaN
5. При сравнении == с null преобразования не происходит, есть жёсткое правило: null == undefined и только.
6. И левая и правая часть == преобразуются к числу 0.*/

////////////////////////////////////////////////////////////////

/*#21*/

//Ответ: 1.

 var i = 3;

while (i) {
  alert( i-- );
}
/*Каждое выполнение цикла уменьшает i. Проверка while(i) даст сигнал «стоп» при i = 0.

Соответственно, шаги цикла:
*/
var i = 3
alert( i-- ); // выведет 3, затем уменьшит i до 2

alert(i--) // выведет 2, затем уменьшит i до 1

alert(i--) // выведет 1, затем уменьшит i до 0

// все, проверка while(i) не даст выполняться циклу дальше

////////////////////////////////////////////////////////////////

/*#22*/

//От 1 до 4

 var i = 0;
while (++i < 5) alert( i );
//Первое значение: i=1, так как операция ++i сначала увеличит i, а потом уже произойдёт сравнение и выполнение alert.

//Далее 2,3,4.. Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как ++ стоит перед переменной.

//При i=4 произойдет увеличение i до 5, а потом сравнение while(5 < 5) – это неверно. Поэтому на этом цикл остановится, и значение 5 выведено не будет.

//От 1 до 5

 var i = 0;
while (i++ < 5) alert( i );
//Первое значение: i=1. Остановимся на нём подробнее. Оператор i++ увеличивает i, возвращая старое значение, так что в сравнении i++ < 5 будет участвовать старое i=0.

//Но последующий вызов alert уже не относится к этому выражению, так что получит новый i=1.

//Далее 2,3,4.. Для каждого значения сначала происходит сравнение, а потом – увеличение, и затем срабатывание alert.

//Окончание цикла: при i=4 произойдет сравнение while(4 < 5) – верно, после этого сработает i++, увеличив i до 5, так что значение 5 будет выведено. Оно станет последним.

////////////////////////////////////////////////////////////////

/*#23*/

//Ответ: от 0 до 4 в обоих случаях.

 for (var i = 0; i < 5; ++i) alert( i );

for (var i = 0; i < 5; i++) alert( i );
//Такой результат обусловлен алгоритмом работы for:

/*Выполнить присвоение i=0
Проверить i<5
Если верно – выполнить тело цикла alert(i), затем выполнить i++
Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.*/

////////////////////////////////////////////////////////////////

/*#24*/

for (var i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
//Чётность проверяется по остатку при делении на 2, используя оператор «деление с остатком» %: i % 2.

////////////////////////////////////////////////////////////////

/*#25*/

var i = 0;
while (i < 3) {
  alert( "номер " + i + "!" );
  i++;
}

////////////////////////////////////////////////////////////////

/*#26*/

var num;

do {
  num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num != null);
/*Цикл do..while повторяется, пока верны две проверки:

Проверка num <= 100 – то есть, введённое число всё еще меньше 100.
Проверка num != null – значение null означает, что посетитель нажал «Отмена», в этом случае цикл тоже нужно прекратить.
Кстати, сравнение num <= 100 при вводе null даст true, так что вторая проверка необходима.*/

////////////////////////////////////////////////////////////////

/*#27*/

/*Схема решения
Для всех i от 1 до 10 {
  проверить, делится ли число i на какое - либо из чисел до него
  если делится, то это i не подходит, берем следующее
  если не делится, то i - простое число
}
Решение
Решение с использованием метки:*/

 nextPrime:
  for (var i = 2; i <= 10; i++) {

    for (var j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
//Конечно же, его можно оптимизировать с точки зрения производительности. Например, проверять все j не от 2 до i, а от 2 до квадратного корня из i. А для очень больших чисел – существуют более эффективные специализированные алгоритмы проверки простоты числа, например квадратичное решето и решето числового поля.

////////////////////////////////////////////////////////////////

/*#28*/

/*Один или ноль
Два*/

////////////////////////////////////////////////////////////////

/*#29*/

//Если совсем точно следовать условию, то сравнение должно быть строгим '==='.

//В реальном случае, скорее всего, подойдёт обычное сравнение '=='.

if(browser == 'IE') {
  alert('О, да у вас IE!');
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert('Да, и эти браузеры мы поддерживаем');
} else {
  alert('Мы надеемся, что и в вашем браузере все ок!');
}
//Обратите внимание: конструкция browser == 'Chrome' || browser == 'Firefox' ... разбита на несколько строк для лучшей читаемости.

//Но всё равно запись через switch нагляднее.

////////////////////////////////////////////////////////////////

/*#30*/

//Первые две проверки – обычный case, третья разделена на два case:

var a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
//Обратите внимание: break внизу не обязателен, но ставится по «правилам хорошего тона».

//Допустим, он не стоит. Есть шанс, что в будущем нам понадобится добавить в конец ещё один case, например case 4, и мы, вполне вероятно, забудем этот break поставить. В результате выполнение case 2/case 3 продолжится на case 4 и будет ошибка.

////////////////////////////////////////////////////////////////

/*#31*/

//Оба варианта функции работают одинаково, отличий нет.

////////////////////////////////////////////////////////////////

/*#32*/

//Используя оператор '?':

function checkAge(age) {
  return (age > 18) ? true : confirm('Родители разрешили?');
}
//Используя оператор || (самый короткий вариант):

function checkAge(age) {
  return (age > 18) || confirm('Родители разрешили?');
}

////////////////////////////////////////////////////////////////

/*#33*/

//Вариант решения с использованием if:

function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
//Вариант решения с оператором '?':

function min(a, b) {
  return a < b ? a : b;
}
//P.S. Случай равенства a == b здесь отдельно не рассматривается, так как при этом неважно, что возвращать.

////////////////////////////////////////////////////////////////

/*#34*/

/**
 * Возводит x в степень n (комментарий JSDoc)
 *
 * @param {number} x число, которое возводится в степень
 * @param {number} n степень, должна быть целым числом больше 1
 *
 * @return {number} x в степени n
 */
function pow(x, n) {
  var result = x;

  for (var i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

var x = prompt("x?", '');
var n = prompt("n?", '');

if (n <= 1) {
  alert('Степень ' + n +
    'не поддерживается, введите целую степень, большую 1'
  );
} else {
  alert( pow(x, n) );
}

////////////////////////////////////////////////////////////////

/*#35*/

//Решение с использованием цикла:

 function sumTo(n) {
  var sum = 0;
  for (var i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
//Решение через рекурсию:

 function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
//Решение по формуле: sumTo(n) = n*(n+1)/2:

 function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
//P.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.

//Вариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов.

//Рекурсия в данном случае работает медленнее всех.

//P.P.S. Существует ограничение глубины вложенных вызовов, поэтому рекурсивный вызов sumTo(100000) выдаст ошибку.

////////////////////////////////////////////////////////////////

/*#36*/

//По свойствам факториала, как описано в условии, n! можно записать как n * (n-1)!.

//То есть, результат функции для n можно получить как n, умноженное на результат функции для n-1, и так далее до 1!:

 function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
//Базисом рекурсии является значение 1. А можно было бы сделать базисом и 0. Тогда код станет чуть короче:

 function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
//В этом случае вызов factorial(1) сведётся к 1*factorial(0), будет дополнительный шаг рекурсии.

////////////////////////////////////////////////////////////////

/*#37*/

/*Вычисление рекурсией (медленное)
Решение по формуле, используя рекурсию:*/

 function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // не запускаем, подвесит браузер
/*При больших значениях n оно будет работать очень медленно. Например, fib(77) уже будет вычисляться очень долго.

Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз. Например, посмотрим на отрывок вычислений:

...*/
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
//...
/*Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено два раза, совершенно независимо.

Можно это оптимизировать, запоминая уже вычисленные значения, получится гораздо быстрее. Альтернативный вариант – вообще отказаться от рекурсии, а вместо этого в цикле начать с первых значений 1, 2, затем из них получить fib(3), далее fib(4), затем fib(5) и так далее, до нужного значения.

Это решение будет наиболее эффективным. Попробуйте его написать.

Алгоритм вычисления в цикле
Будем идти по формуле слева-направо:
*/
var a = 1, b = 1; // начальные значения
var c = a + b; // 2

/* переменные на начальном шаге:
a  b  c
1, 1, 2
*/
//Теперь следующий шаг, присвоим a и b текущие 2 числа и получим новое следующее в c:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
   a  b  c
1, 1, 2, 3
*/
//Следующий шаг даст нам ещё одно число последовательности:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
      a  b  c
1, 1, 2, 3, 5
*/
//Повторять в цикле до тех пор, пока не получим нужное значение. Это гораздо быстрее, чем рекурсия, хотя бы потому что ни одно из чисел не вычисляется дважды.

//P.S. Этот подход к вычислению называется динамическое программирование снизу-вверх.

//Код для вычисления в цикле
 function fib(n) {
  var a = 1,
    b = 1;
  for (var i = 3; i <= n; i++) {
    var c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
//Цикл здесь начинается с i=3, так как первое и второе числа Фибоначчи заранее записаны в переменные a=1, b=1.

////////////////////////////////////////////////////////////////

/*#38*/

//Первый код выведет function ..., второй – ошибку во всех браузерах, кроме IE8-.

 // обычное объявление функции (Function Declaration)
function g() { return 1; };

alert(g); // функция
//Во втором коде скобки есть, значит функция внутри является не Function Declaration, а частью выражения, то есть Named Function Expression. Его имя видно только внутри, снаружи переменная g не определена.

 // Named Function Expression!
(function g() { return 1; });

alert(g);  // Ошибка!
//Все браузеры, кроме IE8-, поддерживают это ограничение видимости и выведут ошибку, "undefined variable".

////////////////////////////////////////////////////////////////

/*#39*/

function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  var result = 1;
  for (var i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}

////////////////////////////////////////////////////////////////

/*#40*/

//Новый тест может быть, к примеру, таким:

it("любое число в степени 0 равно 1", function() {
  assert.equal(pow(123, 0), 1);
});
/*Конечно, желательно проверить на нескольких числах.

Поэтому лучше будет создать блок describe, аналогичный тому, что мы делали для произвольных чисел:*/

describe("любое число, кроме нуля, в степени 0 равно 1", function() {

  function makeTest(x) {
    it("при возведении " + x + " в степень 0 результат: 1", function() {
      assert.equal(pow(x, 0), 1);
    });
  }

  for (var x = -5; x <= 5; x += 2) {
    makeTest(x);
  }

});
/*И не забудем добавить отдельный тест для нуля:

...*/
it("ноль в нулевой степени даёт NaN", function() {
  assert( isNaN(pow(0, 0)), "0 в степени 0 не NaN");
});
//...

////////////////////////////////////////////////////////////////

/*#41*/

/*Этот тест демонстрирует один из соблазнов, которые ожидают начинающего автора тестов.

Вместо того, чтобы написать три различных теста, он изложил их в виде одного потока вычислений, с несколькими assert.

Иногда так написать легче и проще, однако при ошибке в тесте гораздо менее очевидно, что же пошло не так.

Если в сложном тесте произошла ошибка где-то посередине потока вычислений, то придётся выяснять, какие конкретно были входные и выходные данные на этот момент, то есть по сути – отлаживать код самого теста.

Гораздо лучше будет разбить тест на несколько блоков it, с чётко прописанными входными и выходными данными.*/

describe("Возводит x в степень n", function() {
  it("5 в степени 1 равно 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 в степени 2 равно 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 в степени 3 равно 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
//Можно использовать цикл для генерации блоков it, в этом случае важно, чтобы сам код такого цикла был достаточно простым. Иногда проще записать несколько блоков it вручную, как сделано выше, чем «городить огород» из синтаксических конструкций.

////////////////////////////////////////////////////////////////

/*#42*/

//Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности… А впрочем, посмотрим сами:

 alert( 6.35.toFixed(20) ); // 6.34999999999999964473
//Интерпретатор видит число как 6.34..., поэтому и округляет вниз.

////////////////////////////////////////////////////////////////

/*#43*/

//Есть два основных подхода.

//Можно хранить сами цены в «копейках» (центах и т.п.). Тогда они всегда будут целые и проблема исчезнет. Но при показе и при обмене данными нужно будет это учитывать и не забывать делить на 100.

//При операциях, когда необходимо получить окончательный результат – округлять до 2-го знака после запятой. Все, что дальше – ошибка округления:

 var price1 = 0.1, price2 = 0.2;
alert( +(price1 + price2).toFixed(2) );

////////////////////////////////////////////////////////////////

/*#44*/

//Потому что i никогда не станет равным 10.

//Запустите, чтобы увидеть реальные значения i:

 var i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) alert( i );
}
//Ни одно из них в точности не равно 10.

////////////////////////////////////////////////////////////////

/*#45*/

function fibBinet(n) {
  var phi = (1 + Math.sqrt(5)) / 2;
  // используем Math.round для округления до ближайшего целого
  return Math.round(Math.pow(phi, n) / Math.sqrt(5));
}

function fib(n) {
  var a = 1,
    b = 0,
    x;
  for (i = 0; i < n; i++) {
    x = a + b;
    a = b
    b = x;
  }
  return b;
}

alert( fibBinet(2) ); // 1, равно fib(2)
alert( fibBinet(8) ); // 21, равно fib(8)
alert( fibBinet(77) ); // 5527939700884755
alert( fib(77) ); // 5527939700884757, не совпадает!

/*Результат вычисления F77 получился неверным!

Причина – в ошибках округления, ведь √5 – бесконечная дробь.

Ошибки округления при вычислениях множатся и, в итоге, дают расхождение.*/

////////////////////////////////////////////////////////////////

/*#46*/

//Сгенерируем значение в диапазоне 0..1 и умножим на max:

 var max = 10;

alert( Math.random() * max );

////////////////////////////////////////////////////////////////

/*#47*/

/*Очевидное неверное решение (round)
Самый простой, но неверный способ – это сгенерировать значение в интервале min..max и округлить его Math.round, вот так:
*/
 function randomInteger(min, max) {
  var rand = min + Math.random() * (max - min)
  rand = Math.round(rand);
  return rand;
}

alert( randomInteger(1, 3) );
/*Эта функция работает. Но при этом она некорректна: вероятность получить крайние значения min и max будет в два раза меньше, чем любые другие.

При многократном запуске этого кода вы легко заметите, что 2 выпадает чаще всех.

Это происходит из-за того, что Math.round() получает разнообразные случайные числа из интервала от 1 до 3, но при округлении до ближайшего целого получится, что:

значения из диапазона 1   ... 1.49999..  станут 1
значения из диапазона 1.5 ... 2.49999..  станут 2
значения из диапазона 2.5 ... 2.99999..  станут 3
Отсюда явно видно, что в 1 (как и 3) попадает диапазон значений в два раза меньший, чем в 2. Из-за этого такой перекос.

Верное решение с round
Правильный способ: Math.round(случайное от min-0.5 до max+0.5)*/

function randomInteger(min, max) {
    var rand = min - 0.5 + Math.random() * (max - min + 1)
    rand = Math.round(rand);
    return rand;
  }

alert( randomInteger(5, 10) );
/*В этом случае диапазон будет тот же (max-min+1), но учтена механика округления round.

Решение с floor
Альтернативный путь – применить округление Math.floor() к случайному числу от min до max+1.

Например, для генерации целого числа от 1 до 3, создадим вспомогательное случайное значение от 1 до 4 (не включая 4).

Тогда Math.floor() округлит их так:

1 ... 1.999+ станет 1
2 ... 2.999+ станет 2
3 ... 3.999+ станет 3
Все диапазоны одинаковы. Итак, код:*/

function randomInteger(min, max) {
    var rand = min + Math.random() * (max + 1 - min);
    rand = Math.floor(rand);
    return rand;
  }

alert( randomInteger(5, 10) );

////////////////////////////////////////////////////////////////

/*#48*/

/*Мы не можем просто заменить первый символ, т.к. строки в JavaScript неизменяемы.

Но можно пересоздать строку на основе существующей, с заглавным первым символом:*/

var newStr = str[0].toUpperCase() + str.slice(1);
/*Однако, есть небольшая проблемка – в случае, когда строка пуста, будет ошибка.

Ведь str[0] == undefined, а у undefined нет метода toUpperCase().

Выхода два. Первый – использовать str.charAt(0), он всегда возвращает строку, для пустой строки – пустую, но не undefined. Второй – отдельно проверить на пустую строку, вот так:*/

 function ucFirst(str) {
  // только пустая строка в логическом контексте даст false
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("вася") );
//P.S. Возможны и более короткие решения, использующие методы для работы со строками, которые мы пройдём далее.

////////////////////////////////////////////////////////////////

/*#49*/

/*Метод indexOf ищет совпадение с учетом регистра. То есть, в строке 'xXx' он не найдет 'XXX'.

Для проверки, сначала приведем строку str к нижнему регистру, а затем уже будем искать.*/

 function checkSpam(str) {
  var lowerStr = str.toLowerCase();

  return !!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'));
}

alert( checkSpam('buy ViAgRA now') );
alert( checkSpam('free xxxxx') );
alert( checkSpam("innocent rabbit") );

////////////////////////////////////////////////////////////////

/*#50*/

//Так как окончательная длина строки должна быть maxlength, то нужно её обрезать немного короче, чтобы дать место для троеточия.

 function truncate(str, maxlength) {
  if (str.length > maxlength) {
    return str.slice(0, maxlength - 3) + '...';
    // итоговая длина равна maxlength
  }

  return str;
}

alert( truncate("Вот, что мне хотелось бы сказать на эту тему:", 20) );
alert( truncate("Всем привет!", 20) );
//Можно было бы написать этот код ещё короче:

 function truncate(str, maxlength) {
  return (str.length > maxlength) ?
    str.slice(0, maxlength - 3) + '...' : str;
}

////////////////////////////////////////////////////////////////

/*#51*/

//Возьмём часть строки после первого символа и приведём к числу: +str.slice(1).

////////////////////////////////////////////////////////////////

/*#52*/

function isEmpty(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

var schedule = {};

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "подъём";

alert( isEmpty(schedule) ); // false

////////////////////////////////////////////////////////////////

/*#53*/

"use strict";

var salaries = {
  "Вася": 100,
  "Петя": 300,
  "Даша": 250
};

var sum = 0;
for (var name in salaries) {
  sum += salaries[name];
}

alert( sum );

////////////////////////////////////////////////////////////////

/*#54*/

"use strict";

var salaries = {
  "Вася": 100,
  "Петя": 300,
  "Даша": 250
};

var max = 0;
var maxName = "";
for (var name in salaries) {
  if (max < salaries[name]) {
    max = salaries[name];
    maxName = name;
  }
}

alert( maxName || "нет сотрудников" );

////////////////////////////////////////////////////////////////

/*#55*/

var menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function multiplyNumeric(obj) {
  for (var key in obj) {
    if (isNumeric(obj[key])) {
      obj[key] *= 2;
    }
  }
}

multiplyNumeric(menu);

alert( "menu width=" + menu.width + " height=" + menu.height + " title=" + menu.title );

////////////////////////////////////////////////////////////////

/*#56*/

/*
Последний элемент имеет индекс на 1 меньший, чем длина массива.

Например:
*/
var fruits = ["Яблоко", "Груша", "Слива"];
//Длина этого массива fruits.length равна 3. Здесь «Яблоко» имеет индекс 0, «Груша» – индекс 1, «Слива» – индекс 2.

//То есть, для массива длины goods:

var lastItem = goods[goods.length - 1]; // получить последний элемент

////////////////////////////////////////////////////////////////

/*#57*/

//Текущий последний элемент имеет индекс goods.length-1. Значит, индексом нового элемента будет goods.length:

goods[goods.length] = 'Компьютер'

////////////////////////////////////////////////////////////////

/*#58*/

var styles = ["Джаз", "Блюз"];
styles.push("Рок-н-Ролл");
styles[styles.length - 2] = "Классика";
alert( styles.shift() );
styles.unshift("Рэп", "Регги");

////////////////////////////////////////////////////////////////

/*#59*/

//Для вывода нужен случайный номер от 0 до arr.length-1 включительно.

 var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];

var rand = Math.floor(Math.random() * arr.length);

alert( arr[rand] );

////////////////////////////////////////////////////////////////

/*#60*/

//В решение ниже обратите внимание: мы не приводим value к числу сразу после prompt, так как если сделать value = +value, то после этого отличить пустую строку от нуля уже никак нельзя. А нам здесь нужно при пустой строке прекращать ввод, а при нуле – продолжать.

 var numbers = [];

while (true) {

  var value = prompt("Введите число", 0);

  if (value === "" || value === null || isNaN(value)) break;

  numbers.push(+value);
}

var sum = 0;
for (var i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}

alert( sum );

////////////////////////////////////////////////////////////////

/*#61*/

var arr = [1, 2, 3];

var arr2 = arr; // (*)
arr2[0] = 5;

alert( arr[0] );
alert( arr2[0] );
/*Код выведет 5 в обоих случаях, так как массив является объектом. В строке (*) в переменную arr2 копируется ссылка на него, а сам объект в памяти по-прежнему один, в нём отражаются изменения, внесенные через arr2 или arr.

В частности, сравнение arr2 == arr даст true.

Если нужно именно скопировать массив, то это можно сделать, например, так:*/

var arr2 = [];
for (var i = 0; i < arr.length; i++) arr2[i] = arr[i];

////////////////////////////////////////////////////////////////

/*#62*/

//Возможное решение:

function find(array, value) {

  for (var i = 0; i < array.length; i++) {
    if (array[i] == value) return i;
  }

  return -1;
}
//Однако, в нем ошибка, т.к. сравнение == не различает 0 и false.

//Поэтому лучше использовать ===. Кроме того, в современном стандарте JavaScript существует встроенная функция Array#indexOf, которая работает именно таким образом. Имеет смысл ей воспользоваться, если браузер ее поддерживает.

 function find(array, value) {
  if (array.indexOf) { // если метод существует
    return array.indexOf(value);
  }

  for (var i = 0; i < array.length; i++) {
    if (array[i] === value) return i;
  }

  return -1;
}

var arr = ["a", -1, 2, "b"];

var index = find(arr, 2);

alert( index );
//… Но еще лучшим вариантом было бы определить find по-разному в зависимости от поддержки браузером метода indexOf:

// создаем пустой массив и проверяем поддерживается ли indexOf
if ([].indexOf) {

  var find = function(array, value) {
    return array.indexOf(value);
  }

} else {
  var find = function(array, value) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === value) return i;
    }

    return -1;
  }

}
//Этот способ – лучше всего, т.к. не требует при каждом запуске find проверять поддержку indexOf.

////////////////////////////////////////////////////////////////

/*#63*/

/*Алгоритм решения
Создайте временный пустой массив var results = [].
Пройдите по элементам arr в цикле и заполните его.
Возвратите results.
Решение*/
 function filterRange(arr, a, b) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] >= a && arr[i] <= b) {
      result.push(arr[i]);
    }
  }

  return result;
}

var arr = [5, 4, 3, 8, 0];

var filtered = filterRange(arr, 3, 5);
alert( filtered );

////////////////////////////////////////////////////////////////

/*#64*/

//Их сумма равна 1060.

 // шаг 1
var arr = [];

for (var i = 2; i < 100; i++) {
  arr[i] = true
}

// шаг 2
var p = 2;

do {
  // шаг 3
  for (i = 2 * p; i < 100; i += p) {
    arr[i] = false;
  }

  // шаг 4
  for (i = p + 1; i < 100; i++) {
    if (arr[i]) break;
  }

  p = i;
} while (p * p < 100); // шаг 5

// шаг 6 (готово)
// посчитать сумму
var sum = 0;
for (i = 0; i < arr.length; i++) {
  if (arr[i]) {
    sum += i;
  }
}

alert( sum );

////////////////////////////////////////////////////////////////

/*#65*/

//Подсказка (медленное решение)
/*Можно просто посчитать для каждого элемента массива все суммы, которые с него начинаются.

Например, для [-1, 2, 3, -9, 11]:

// Начиная с -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Начиная с 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Начиная с 3:
3
3 + (-9)
3 + (-9) + 11

// Начиная с -9
-9
-9 + 11

// Начиная с 11
11
Сделайте вложенный цикл, который на внешнем уровне бегает по элементам массива, а на внутреннем – формирует все суммы элементов, которые начинаются с текущей позиции.

Медленное решение
Решение через вложенный цикл:*/

 function getMaxSubSum(arr) {
  var maxSum = 0; // если совсем не брать элементов, то сумма 0

  for (var i = 0; i < arr.length; i++) {
    var sumFixedStart = 0;
    for (var j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
/*Такое решение имеет оценку сложности O(n2), то есть при увеличении массива в 2 раза алгоритм требует в 4 раза больше времени. На больших массивах (1000, 10000 и более элементов) такие алгоритмы могут приводить к серьёзным «тормозам».

Подсказка (быстрое решение)
Будем идти по массиву и накапливать в некоторой переменной s текущую частичную сумму. Если в какой-то момент s окажется отрицательной, то мы просто присвоим s=0. Утверждается, что максимум из всех значений переменной s, случившихся за время работы, и будет ответом на задачу.

Докажем этот алгоритм.

В самом деле, рассмотрим первый момент времени, когда сумма s стала отрицательной. Это означает, что, стартовав с нулевой частичной суммы, мы в итоге пришли к отрицательной частичной сумме – значит, и весь этот префикс массива, равно как и любой его суффикс имеют отрицательную сумму.

Следовательно, от всего этого префикса массива в дальнейшем не может быть никакой пользы: он может дать только отрицательную прибавку к ответу.*/


//Быстрое решение
 function getMaxSubSum(arr) {
  var maxSum = 0,
    partialSum = 0;
  for (var i = 0; i < arr.length; i++) {
    partialSum += arr[i];
    maxSum = Math.max(maxSum, partialSum);
    if (partialSum < 0) partialSum = 0;
  }
  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
//Информацию об алгоритме вы также можете прочитать здесь: http://e-maxx.ru/algo/maximum_average_segment и здесь: Maximum subarray problem.

//Этот алгоритм требует ровно одного прохода по массиву, его сложность имеет оценку O(n).

////////////////////////////////////////////////////////////////

/*#66*/

//Решение заключается в превращении obj.className в массив при помощи split. После этого в нем можно проверить наличие класса, и если нет – добавить.

 function addClass(obj, cls) {
  var classes = obj.className ? obj.className.split(' ') : [];

  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == cls) return; // класс уже есть
  }

  classes.push(cls); // добавить

  obj.className = classes.join(' '); // и обновить свойство
}

var obj = {
  className: 'open menu'
};

addClass(obj, 'new');
addClass(obj, 'open');
addClass(obj, 'me');
alert(obj.className) // open menu new me
/*P.S. «Альтернативный» подход к проверке наличия класса вызовом obj.className.indexOf(cls) был бы неверным. В частности, он найдёт cls = "menu" в строке классов obj.className = "open mymenu".

P.P.S. Проверьте, нет ли в вашем решении присвоения obj.className += " " + cls. Не добавляет ли оно лишний пробел в случае, если изначально obj.className = ""?*/

////////////////////////////////////////////////////////////////

/*#67*/

/*Идея
Задача может быть решена несколькими способами. Один из них – разбить строку по дефису str.split('-'), затем последовательно сконструировать новую.

Решение
Разобьем строку в массив, а затем преобразуем его элементы и сольём обратно:*/

 function camelize(str) {
  var arr = str.split('-');

  for (var i = 1; i < arr.length; i++) {
    // преобразовать: первый символ с большой буквы
    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
  }

  return arr.join('');
}

alert( camelize("background-color") ); // backgroundColor
alert( camelize("list-style-image") ); // listStyleImage
alert( camelize("-webkit-transition") ); // WebkitTransition

////////////////////////////////////////////////////////////////

/*#68*/

/*Решение заключается в том, чтобы разбить className в массив классов, а затем пройтись по нему циклом. Если класс есть – удаляем его splice, заново объединяем массив в строку и присваиваем объекту.*/

function removeClass(obj, cls) {
  var classes = obj.className.split(' ');

  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == cls) {
      classes.splice(i, 1); // удалить класс
      i--; // (*)
    }
  }
  obj.className = classes.join(' ');

}

var obj = {
  className: 'open menu menu'
}

removeClass(obj, 'blabla');
removeClass(obj, 'menu')
alert(obj.className) // open
/*В примере выше есть тонкий момент. Элементы массива проверяются один за другим. При вызове splice удаляется текущий, i-й элемент, и те элементы, которые идут дальше, сдвигаются на его место.

Таким образом, на месте i оказывается новый, непроверенный элемент.

Чтобы это учесть, строчка (*) уменьшает i, чтобы следующая итерация цикла заново проверила элемент с номером i. Без нее функция будет работать с ошибками.*/

////////////////////////////////////////////////////////////////

/*#69*/

function filterRangeInPlace(arr, a, b) {

  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (val < a || val > b) {
      arr.splice(i--, 1);
    }
  }

}

var arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4);
alert( arr ); // [3, 1]

////////////////////////////////////////////////////////////////

/*#70*/

var arr = [5, 2, 1, -10, 8];

function compareReversed(a, b) {
  return b - a;
}

arr.sort(compareReversed);

alert( arr );

////////////////////////////////////////////////////////////////

/*#71*/

//Для копирования массива используем slice(), и тут же – сортировку:

var arr = ["HTML", "JavaScript", "CSS"];

var arrSorted = arr.slice().sort();

alert( arrSorted );
alert( arr );

////////////////////////////////////////////////////////////////

/*#72*/

/*Подсказка
Функция сортировки должна возвращать случайный результат сравнения. Используйте для этого Math.random.

Решение
Обычно Math.random() возвращает результат от 0 до 1. Вычтем 0.5, чтобы область значений стала [-0.5 ... 0.5).
*/
var arr = [1, 2, 3, 4, 5];

function compareRandom(a, b) {
  return Math.random() - 0.5;
}

arr.sort(compareRandom);

alert( arr ); // элементы в случайном порядке, например [3,5,1,2,4]

////////////////////////////////////////////////////////////////

/*#73*/

//Для сортировки объявим и передадим в sort функцию, которая сравнивает объекты по полю age:

// Наша функция сравнения
function compareAge(personA, personB) {
  return personA.age - personB.age;
}

// проверка
var vasya = { name: "Вася", age: 23 };
var masha = { name: "Маша", age: 18 };
var vovochka = { name: "Вовочка", age: 6 };

var people = [ vasya , masha , vovochka ];

people.sort(compareAge);

// вывести
for(var i = 0; i < people.length; i++) {
  alert(people[i].name); // Вовочка Маша Вася
}

////////////////////////////////////////////////////////////////

/*#74*/

//Вывод списка в цикле
 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  var tmp = list;

  while (tmp) {
    alert( tmp.value );
    tmp = tmp.next;
  }

}

printList(list);
/*Обратите внимание, что для прохода по списку используется временная переменная tmp, а не list. Можно было бы и бегать по списку, используя входной параметр функции:*/



            function printList(list) {

  while(list) {
    alert( list.value );
    list = list.next;
  }

}
/*…Но при этом мы в будущем не сможем расширить функцию и сделать со списком что-то ещё, ведь после окончания цикла начало списка уже нигде не хранится.

Поэтому и используется временная переменная – чтобы сделать код расширяемым, и, кстати, более понятным, ведь роль tmp – исключительно обход списка, как i в цикле for.

Вывод списка с рекурсией
Рекурсивный вариант printList(list) следует простой логике: вывести текущее значение (1), а затем пропустить через себя следующее (2):*/

 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert( list.value ); // (1)

  if (list.next) {
    printList(list.next); // (2)
  }

}

printList(list);
/*Обратный вывод с рекурсией
Обратный вывод – почти то же самое, что прямой, просто сначала мы обрабатываем следующее значение, а потом – текущее:*/

 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert( list.value );
}

printReverseList(list);
Обратный вывод без рекурсии
 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  var arr = [];
  var tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (var i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
/*Обратный вывод без рекурсии быстрее.

По сути, рекурсивный вариант и нерекурсивный работают одинаково: они проходят список и запоминают его элементы, а потом выводят в обратном порядке.

В случае с массивом это очевидно, а для рекурсии запоминание происходит в стеке (внутренней специальной структуре данных): когда вызывается вложенная функция, то интерпретатор сохраняет в стек текущие параметры. Вложенные вызовы заполняют стек, а потом он выводится в обратном порядке.

При этом, при рекурсии в стеке сохраняется не только элемент списка, а другая вспомогательная информация, необходимая для возвращения из вложенного вызова. Поэтому тратится больше памяти. Все эти расходы отсутствуют в варианте без рекурсии, так как в массиве хранится именно то, что нужно.

Преимущество рекурсии, с другой стороны – более короткий и, зачастую, более простой код.

////////////////////////////////////////////////////////////////

/*#75*/

/*Чтобы обнаружить анаграммы, разобьём каждое слово на буквы и отсортируем их. В отсортированном по буквам виде все анаграммы одинаковы.

Например:

воз, зов -> взо
киборг, гробик -> бгикор
...
По такой последовательности будем делать массив уникальным.

Для этого воспользуемся вспомогательным объектом, в который будем записывать слова по отсортированному ключу:*/

function aclean(arr) {
  // этот объект будем использовать для уникальности
  var obj = {};

  for (var i = 0; i < arr.length; i++) {
    // разбить строку на буквы, отсортировать и слить обратно
    var sorted = arr[i].toLowerCase().split('').sort().join(''); // (*)

    obj[sorted] = arr[i]; // сохраняет только одно значение с таким ключом
  }

  var result = [];

  // теперь в obj находится для каждого ключа ровно одно значение
  for (var key in obj) result.push(obj[key]);

  return result;
}

var arr = ["воз", "киборг", "корсет", "ЗОВ", "гробик", "костер", "сектор"];

alert( aclean(arr) );
/*Приведение слова к сортированному по буквам виду осуществляется цепочкой вызовов в строке (*).

Для удобства комментирования разобьём её на несколько строк (JavaScript это позволяет):*/

var sorted = arr[i] // ЗОВ
  .toLowerCase() // зов
  .split('') // ['з','о','в']
  .sort() // ['в','з','о']
  .join(''); // взо
/*Получится, что два разных слова 'ЗОВ' и 'воз' получат одинаковую отсортированную форму 'взо'.

Следующая строка:

obj[sorted] = arr[i];
В объект obj будет записано сначала первое из слов obj['взо'] = "воз", а затем obj['взо'] = 'ЗОВ'.

Обратите внимание, ключ – отсортирован, а само слово – в исходной форме, чтобы можно было потом получить его из объекта.

Вторая запись по тому же ключу перезапишет первую, то есть в объекте останется ровно одно слово с таким набором букв.*/

////////////////////////////////////////////////////////////////

/*#76*/

/*Решение перебором (медленное)
Пройдём по массиву вложенным циклом.

Для каждого элемента мы будем искать, был ли такой уже. Если был – игнорировать:*/

 function unique(arr) {
  var result = [];

  nextInput:
    for (var i = 0; i < arr.length; i++) {
      var str = arr[i]; // для каждого элемента
      for (var j = 0; j < result.length; j++) { // ищем, был ли он уже?
        if (result[j] == str) continue nextInput; // если да, то следующий
      }
      result.push(str);
    }

  return result;
}

var strings = ["кришна", "кришна", "харе", "харе",
  "харе", "харе", "кришна", "кришна", "8-()"
];

alert( unique(strings) ); // кришна, харе, 8-()
/*Давайте посмотрим, насколько быстро он будет работать.

Предположим, в массиве 100 элементов. Если все они одинаковые, то result будет состоять из одного элемента и вложенный цикл будет выполняться сразу. В этом случае всё хорошо.

А если все, или почти все элементы разные?

В этом случае для каждого элемента понадобится обойти весь текущий массив результатов, после чего – добавить в этот массив.

Для первого элемента – это обойдётся в 0 операций доступа к элементам result (он пока пустой).
Для второго элемента – это обойдётся в 1 операцию доступа к элементам result.
Для третьего элемента – это обойдётся в 2 операции доступа к элементам result.
…Для n-го элемента – это обойдётся в n-1 операций доступа к элементам result.
Всего 0 + 1 + 2 + … + n-1 = (n-1)*n/2 = n2/2 – n/2 (как сумма арифметической прогрессии), то есть количество операций растёт примерно как квадрат от n.

Это очень быстрый рост. Для 100 элементов – 4950 операций, для 1000 – 499500 (по формуле выше).

Поэтому такое решение подойдёт только для небольших массивов. Вместо вложенного for можно использовать и arr.indexOf, ситуация от этого не поменяется, так как indexOf тоже ищет перебором.

Решение с объектом (быстрое)
Наилучшая техника для выбора уникальных строк – использование вспомогательного объекта obj. Ведь название свойства в объекте, с одной стороны – строка, а с другой – всегда уникально. Повторная запись в свойство с тем же именем перезапишет его.

Например, если "харе" попало в объект один раз (obj["харе"] = true), то второе такое же присваивание ничего не изменит.

Решение ниже создаёт объект obj = {} и записывает в него все строки как имена свойств. А затем собирает свойства из объекта в массив через Object.keys(). Дубликатов уже не будет.*/

function unique(arr) {
  var obj = {};

  for (var i = 0; i < arr.length; i++) {
    var str = arr[i];
    obj[str] = true; // запомнить строку в виде свойства объекта
  }

  return Object.keys(obj); // или собрать ключи перебором для IE8-
}

var strings = ["кришна", "кришна", "харе", "харе",
  "харе", "харе", "кришна", "кришна", "8-()"
];

alert( unique(strings) ); // кришна, харе, 8-()
/*Так что можно положить все значения как ключи в объект, а потом достать.*/

////////////////////////////////////////////////////////////////

/*#77*/

var arr = ["Есть", "жизнь", "на", "Марсе"];

var arrLength = arr.map(function(item) {
  return item.length;
});

alert( arrLength ); // 4,5,2,5

////////////////////////////////////////////////////////////////

/*#78*/

/*Метод arr.reduce подходит здесь идеально. Достаточно пройтись по массиву слева-направо, накапливая текущую сумму в переменной и, кроме того, добавляя её в результирующий массив.

Неправильный вариант может выглядеть так:*/
function getSums(arr) {
  var result = [];
  if (!arr.length) return result;

  arr.reduce(function(sum, item) {
    result.push(sum);
    return sum + item;
  });

  return result;
}

alert(getSums([1,2,3,4,5])); // результат: 1,3,6,10
/*Перед тем, как читать дальше, посмотрите на него внимательно. Заметили, в чём ошибка?

Если вы его запустите, то обнаружите, что результат не совсем тот. В получившемся массиве всего четыре элемента, отсутствует последняя сумма.

Это из-за того, что последняя сумма является результатом метода reduce, он на ней заканчивает проход и далее функцию не вызывает, поэтому она оказывается не добавленной в result.

Исправим это:*/

function getSums(arr) {
  var result = [];
  if (!arr.length) return result;

  var totalSum = arr.reduce(function(sum, item) {
    result.push(sum);
    return sum + item;
  });
  result.push(totalSum);

  return result;
}

alert(getSums([1,2,3,4,5])); // 1,3,6,10,15
alert(getSums([-2,-1,0,1])); // -2,-3,-3,-2

////////////////////////////////////////////////////////////////

/*#79*/

//Узнать количество реально переданных аргументов можно по значению arguments.length:

 function f(x) {
  alert( arguments.length ? 1 : 0 );
}

f(undefined);
f();

////////////////////////////////////////////////////////////////

/*#80*/

function sum() {
  var result = 0;

  for (var i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }

  return result;
}

alert( sum() ); // 0
alert( sum(1) ); // 1
alert( sum(1, 2) ); // 3
alert( sum(1, 2, 3) ); // 6
alert( sum(1, 2, 3, 4) ); // 10

////////////////////////////////////////////////////////////////

/*#81*/

/*Дата в местной временной зоне создается при помощи new Date.

Месяцы начинаются с нуля, так что февраль имеет номер 1. Параметры можно указывать с точностью до минут:*/

 var d = new Date(2012, 1, 20, 3, 12);
alert( d );

////////////////////////////////////////////////////////////////

/*#82*/

/*Метод getDay() позволяет получить номер дня недели, начиная с воскресенья.

Запишем имена дней недели в массив, чтобы можно было их достать по номеру:*/

 function getWeekDay(date) {
  var days = ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'];

  return days[date.getDay()];
}

var date = new Date(2014, 0, 3); // 3 января 2014
alert( getWeekDay(date) ); // 'пт'
//В современных браузерах можно использовать и toLocaleString:

 var date = new Date(2014, 0, 3); // 3 января 2014
alert( date.toLocaleString('ru', {weekday: 'short'}) ); // 'Пт'

////////////////////////////////////////////////////////////////

/*#83*/

//Решение – в использовании встроенной функции getDay. Она полностью подходит нашим целям, но для воскресенья возвращает 0 вместо 7:

 function getLocalDay(date) {

  var day = date.getDay();

  if (day == 0) { // день 0 становится 7
    day = 7;
  }

  return day;
}

alert( getLocalDay(new Date(2012, 0, 3)) ); // 2
//Если удобнее, чтобы день недели начинался с нуля, то можно возвращать в функции day - 1, тогда дни будут от 0 (пн) до 6(вс).

////////////////////////////////////////////////////////////////

/*#84*/

//Из даты date нужно вычесть указанное количество дней. Это просто:

function getDateAgo(date, days) {
  date.setDate(date.getDate() - days);
  return date.getDate();
}
//Ситуацию осложняет то, что исходный объект даты не должен меняться. Это разумное требование, оно позволит избежать сюрпризов.

//Для того чтобы ему соответствовать, создадим копию объекта даты:

 function getDateAgo(date, days) {
  var dateCopy = new Date(date);

  dateCopy.setDate(date.getDate() - days);
  return dateCopy.getDate();
}

var date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 января 2015)
alert( getDateAgo(date, 2) ); // 31, (31 декабря 2014)
alert( getDateAgo(date, 365) ); // 2, (2 января 2014)

////////////////////////////////////////////////////////////////

/*#85*/

function getLastDayOfMonth(year, month) {
  var date = new Date(year, month + 1, 0);
  return date.getDate();
}

alert( getLastDayOfMonth(2012, 0) ); // 31
alert( getLastDayOfMonth(2012, 1) ); // 29
alert( getLastDayOfMonth(2013, 1) ); // 28

////////////////////////////////////////////////////////////////

/*#86*/

//Для вывода достаточно сгенерировать объект Date, соответствующий началу дня, т.е. «сегодня» 00 часов 00 минут 00 секунд, и вычесть его из текущей даты.

//Полученная разница – это как раз количество миллисекунд от начала дня, которое достаточно поделить на 1000, чтобы получить секунды:

 function getSecondsToday() {
  var now = new Date();

  // создать объект из текущей даты, без часов-минут-секунд
  var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  var diff = now - today; // разница в миллисекундах
  return Math.floor(diff / 1000); // перевести в секунды
}

alert( getSecondsToday() );
//Альтернативное решение – получить часы/минуты/секунды и преобразовать их все в секунды:

 function getSecondsToday() {
  var d = new Date();
  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
};

////////////////////////////////////////////////////////////////

/*#87*/

//Для получения оставшихся до конца дня миллисекунд нужно из «завтра 00 ч 00 мин 00 сек» вычесть текущее время.

//Чтобы сгенерировать «завтра» – увеличим текущую дату на 1 день:
function getSecondsToTomorrow() {
  var now = new Date();

  // создать объект из завтрашней даты, без часов-минут-секунд
  var tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);

  var diff = tomorrow - now; // разница в миллисекундах
  return Math.round(diff / 1000); // перевести в секунды
}

////////////////////////////////////////////////////////////////

/*#88*/

//получим компоненты один за другим.

//День можно получить как date.getDate(). При необходимости добавим ведущий ноль:

var dd = date.getDate();
if (dd < 10) dd = '0' + dd;
date.getMonth() возвратит месяц, начиная с нуля. Увеличим его на 1:

var mm = date.getMonth() + 1; // месяц 1-12
if (mm < 10) mm = '0' + mm;
date.getFullYear() вернет год в 4-значном формате. Чтобы сделать его двузначным – воспользуемся оператором взятия остатка '%':

var yy = date.getFullYear() % 100;
if (yy < 10) yy = '0' + yy;
//Заметим, что год, как и другие компоненты, может понадобиться дополнить нулем слева, причем возможно что yy == 0 (например, 2000 год). При сложении со строкой 0+'0' == '00', так что будет все в порядке.

//Полный код:

 function formatDate(date) {

  var dd = date.getDate();
  if (dd < 10) dd = '0' + dd;

  var mm = date.getMonth() + 1;
  if (mm < 10) mm = '0' + mm;

  var yy = date.getFullYear() % 100;
  if (yy < 10) yy = '0' + yy;

  return dd + '.' + mm + '.' + yy;
}

var d = new Date(2014, 0, 30); // 30 Янв 2014
alert( formatDate(d) ); // '30.01.14'

////////////////////////////////////////////////////////////////

/*#89*/

//Для того, чтобы узнать время от date до текущего момента – используем вычитание дат.

 function formatDate(date) {
  var diff = new Date() - date; // разница в миллисекундах

  if (diff < 1000) { // прошло менее 1 секунды
    return 'только что';
  }

  var sec = Math.floor(diff / 1000); // округлить diff до секунд

  if (sec < 60) {
    return sec + ' сек. назад';
  }

  var min = Math.floor(diff / 60000); // округлить diff до минут
  if (min < 60) {
    return min + ' мин. назад';
  }

  // форматировать дату, с учетом того, что месяцы начинаются с 0
  var d = date;
  d = [
    '0' + d.getDate(),
    '0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ];

  for (var i = 0; i < d.length; i++) {
    d[i] = d[i].slice(-2);
  }

  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
}

alert( formatDate(new Date(new Date - 1)) ); // только что

alert( formatDate(new Date(new Date - 30 * 1000)) ); // 30 сек. назад

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // 5 мин. назад

alert( formatDate(new Date(new Date - 86400 * 1000)) ); // вчерашняя дата в формате "дд.мм.гг чч:мм"

////////////////////////////////////////////////////////////////

/*#90*/

//Ответ: 1.

 if ("a" in window) {
  var a = 1;
}
alert( a );
//Посмотрим, почему.

//На стадии подготовки к выполнению, из var a создается window.a:

// window = {a:undefined}

if ("a" in window) { // в if видно что window.a уже есть
  var a = 1; // поэтому эта строка сработает
}
alert( a );
//В результате a становится 1.

////////////////////////////////////////////////////////////////

/*#91*/

//Ответ: ошибка.

//Переменной a нет, так что условие "a" in window не выполнится. В результате на последней строчке – обращение к неопределенной переменной.

 if ("a" in window) {
  a = 1;
}
alert( a ); // <-- error!

////////////////////////////////////////////////////////////////

/*#92*/

//Переменная a создается до начала выполнения кода, так что условие "a" in window выполнится и сработает a = 1.

 if ("a" in window) {
  a = 1;
}
var a;

alert( a ); // 1

////////////////////////////////////////////////////////////////

/*#93*/

//Ошибки не будет, выведет "Вася, undefined".

 say('Вася'); // Что выведет? Не будет ли ошибки?

var phrase = 'Привет';

function say(name) {
  alert( name + ", " + phrase );
}
//Переменная как таковая существует, вот только на момент запуска функции она равна undefined.

////////////////////////////////////////////////////////////////

/*#94*/

/*Результатом будет true, т.к. var обработается и переменная будет создана до выполнения кода.

Соответственно, присвоение value=true сработает на локальной переменной, и alert выведет true.

Внешняя переменная не изменится.

P.S. Если var нет, то в функции переменная не будет найдена. Интерпретатор обратится за ней в window и изменит её там.

Так что без var результат будет также true, но внешняя переменная изменится.*/

////////////////////////////////////////////////////////////////

/*#95*/

//Результатом будет undefined, затем 5.

 function test() {

  alert( window );

  var window = 5;

  alert( window );
}

test();
//Такой результат получился потому, что window – это глобальная переменная, но ничто не мешает объявить такую же локальную.

//Директива var window обработается до начала выполнения кода функции и будет создана локальная переменная, т.е. свойство LexicalEnvironment.window:

LexicalEnvironment = {
  window: undefined
}
/*Когда выполнение кода начнется и сработает alert, он выведет уже локальную переменную, которая на тот момент равна undefined.

Затем сработает присваивание, и второй alert выведет уже 5.*/

////////////////////////////////////////////////////////////////

/*#96*/

//Результат – ошибка. Попробуйте:

 var a = 5

(function() {
  alert(a)
})()
//Дело в том, что после var a = 5 нет точки с запятой.

//JavaScript воспринимает этот код как если бы перевода строки не было:

 var a = 5(function() {
  alert(a)
})()
//То есть, он пытается вызвать функцию 5, что и приводит к ошибке.

//Если точку с запятой поставить, все будет хорошо:

 var a = 5;

(function() {
  alert(a)
})()
//Это один из наиболее частых и опасных подводных камней, приводящих к ошибкам тех, кто не ставит точки с запятой.

////////////////////////////////////////////////////////////////

/*#97*/

/*Нет, нельзя.

Локальная переменная полностью перекрывает внешнюю.*/

////////////////////////////////////////////////////////////////

/*#98*/

/*Выведут 1,2,3,4.

Здесь внутренняя функция будет искать – и находить currentCount каждый раз в самом внешнем объекте переменных: глобальном объекте window.

В результате все счётчики будут разделять единое, глобальное текущее значение.*/

var currentCount = 1;

function makeCounter() {
  return function() {
    return currentCount++;
  };
}

var counter = makeCounter();
var counter2 = makeCounter();

alert( counter() ); // 1
alert( counter() ); // 2

alert( counter2() ); // 3
alert( counter2() ); // 4

////////////////////////////////////////////////////////////////

/*#99*/

//Чтобы вторые скобки в вызове работали – первые должны возвращать функцию.

//Эта функция должна знать про a и уметь прибавлять a к b. Вот так:

 function sum(a) {

  return function(b) {
    return a + b; // возьмет a из внешнего LexicalEnvironment
  };

}

alert( sum(1)(2) );
alert( sum(5)(-1) );

////////////////////////////////////////////////////////////////

/*#100*/

//Текущее значение текста удобно хранить в замыкании, в локальной переменной makeBuffer:

 function makeBuffer() {
  var text = '';

  return function(piece) {
    if (arguments.length == 0) { // вызов без аргументов
      return text;
    }
    text += piece;
  };
};

var buffer = makeBuffer();

// добавить значения к буферу
buffer('Замыкания');
buffer(' Использовать');
buffer(' Нужно!');
alert( buffer() ); // 'Замыкания Использовать Нужно!'

var buffer2 = makeBuffer();
buffer2(0);
buffer2(1);
buffer2(0);

alert( buffer2() ); // '010'
//Начальное значение text = '' – пустая строка. Поэтому операция text += piece прибавляет piece к строке, автоматически преобразуя его к строковому типу, как и требовалось в условии.

//Открыть решение с тестами в песочнице.

////////////////////////////////////////////////////////////////

/*#101*/

function makeBuffer() {
  var text = '';

  function buffer(piece) {
    if (arguments.length == 0) { // вызов без аргументов
      return text;
    }
    text += piece;
  };

  buffer.clear = function() {
    text = "";
  }

  return buffer;
};

var buffer = makeBuffer();

buffer("Тест");
buffer(" тебя не съест ");
alert( buffer() ); // Тест тебя не съест

buffer.clear();

alert( buffer() ); // ""

////////////////////////////////////////////////////////////////

/*#102*/

var users = [{
  name: "Вася",
  surname: 'Иванов',
  age: 20
}, {
  name: "Петя",
  surname: 'Чапаев',
  age: 25
}, {
  name: "Маша",
  surname: 'Медведева',
  age: 18
}];

function byField(field) {
    return function(a, b) {
      return a[field] > b[field] ? 1 : -1;
    }
  }

users.sort(byField('name'));
users.forEach(function(user) {
  alert( user.name );
});

users.sort(byField('age'));
users.forEach(function(user) {
  alert( user.name );
});

////////////////////////////////////////////////////////////////

/*#103*/

//Функция фильтрации
 function filter(arr, func) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (func(val)) {
      result.push(val);
    }
  }

  return result;
}

var arr = [1, 2, 3, 4, 5, 6, 7];

alert(filter(arr, function(a) {
  return a % 2 == 0;
})); // 2, 4, 6
//Фильтр inBetween

function filter(arr, func) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (func(val)) {
      result.push(val);
    }
  }

  return result;
}

function inBetween(a, b) {
    return function(x) {
      return x >= a && x <= b;
    };
  }

var arr = [1, 2, 3, 4, 5, 6, 7];
alert( filter(arr, inBetween(3, 6)) ); // 3,4,5,6
//Фильтр inArray

function filter(arr, func) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (func(val)) {
      result.push(val);
    }
  }

  return result;
}

function inArray(arr) {
    return function(x) {
      return arr.indexOf(x) != -1;
    };
  }

var arr = [1, 2, 3, 4, 5, 6, 7];
alert( filter(arr, inArray([1, 2, 10])) ); // 1,2

////////////////////////////////////////////////////////////////

/*#104*/

/*Что происходит в этом коде
Функция makeArmy делает следующее:

Создаёт пустой массив shooters:*/

var shooters = [];
//В цикле заполняет массив элементами через shooters.push. При этом каждый элемент массива – это функция, так что в итоге после цикла массив будет таким:

shooters = [
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); }
];
/*Этот массив возвращается из функции.

Вызов army[5]() – это получение элемента массива (им будет функция), и тут же – её запуск.

Почему ошибка
Вначале разберемся, почему все стрелки выводят одно и то же значение.

В функциях-стрелках shooter отсутствует переменная i. Когда такая функция вызывается, то i она берет из внешнего LexicalEnvironment.

Чему же будет равно это значение i?

К моменту вызова army[0](), функция makeArmy уже закончила работу. Цикл завершился, последнее значение было i=10.

В результате все функции shooter получают из внешнего лексического окружения это, одно и то же, последнее, значение i=10.

Попробуйте исправить проблему самостоятельно.

Исправление (3 варианта)
Есть несколько способов исправить ситуацию.

Первый способ исправить код – это привязать значение непосредственно к функции-стрелку:
*/
function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++) {

    var shooter = function me() {
      alert( me.i );
    };
    shooter.i = i;

    shooters.push(shooter);
  }

  return shooters;
}

var army = makeArmy();

army[0](); // 0
army[1](); // 1
/*В этом случае каждая функция хранит в себе свой собственный номер.

Кстати, обратите внимание на использование Named Function Expression, вот в этом участке:*/

//...
var shooter = function me() {
  alert( me.i );
};
//...
//Если убрать имя me и оставить обращение через shooter, то работать не будет:

for (var i = 0; i < 10; i++) {
  var shooter = function() {
    alert( shooter.i ); // вывести свой номер (не работает!)
    // потому что откуда функция возьмёт переменную shooter?
    // ..правильно, из внешнего объекта, а там она одна на всех
  };
  shooter.i = i;
  shooters.push(shooter);
}
/*Вызов alert(shooter.i) при вызове будет искать переменную shooter, а эта переменная меняет значение по ходу цикла, и к моменту вызова она равна последней функции, созданной в цикле.

Если использовать Named Function Expression, то имя жёстко привязывается к конкретной функции, и поэтому в коде выше me.i возвращает правильный i.

Другое, более продвинутое решение – использовать дополнительную функцию для того, чтобы «поймать» текущее значение i:*/

function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++) {

    var shooter = (function(x) {

      return function() {
        alert( x );
      };

    })(i);

    shooters.push(shooter);
  }

  return shooters;
}

var army = makeArmy();

army[0](); // 0
army[1](); // 1
//Посмотрим выделенный фрагмент более внимательно, чтобы понять, что происходит:

var shooter = (function(x) {
  return function() {
    alert( x );
  };
})(i);
/*Функция shooter создана как результат вызова промежуточного функционального выражения function(x), которое объявляется – и тут же выполняется, получая x = i.

Так как function(x) тут же завершается, то значение x больше не меняется. Оно и будет использовано в возвращаемой функции-стрелке.

Для красоты можно изменить название переменной x на i, суть происходящего при этом не изменится:*/

var shooter = (function(i) {
  return function() {
    alert( i );
  };
})(i);
//Кстати, обратите внимание – скобки вокруг function(i) не нужны, можно и так:

var shooter = function(i) { // без скобок вокруг function(i)
  return function() {
    alert( i );
  };
}(i);
//Скобки добавлены в код для лучшей читаемости, чтобы человек, который просматривает его, не подумал, что var shooter = function, а понял что это вызов «на месте», и присваивается его результат.

//Еще один забавный способ – обернуть весь цикл во временную функцию:

function makeArmy() {

  var shooters = [];

  for (var i = 0; i < 10; i++)(function(i) {

    var shooter = function() {
      alert( i );
    };

    shooters.push(shooter);

  })(i);

  return shooters;
}

var army = makeArmy();

army[0](); // 0
army[1](); // 1
//Вызов (function(i) { ... }) обернут в скобки, чтобы интерпретатор понял, что это Function Expression.

//Плюс этого способа – в большей читаемости. Фактически, мы не меняем создание shooter, а просто обертываем итерацию в функцию.

////////////////////////////////////////////////////////////////

/*#105*/

//Вторая (2), т.к. при обращении к любой переменной внутри with – она ищется прежде всего в объекте.

//Соответственно, будет выведено 2:

 function f() {
  alert(1)
}

var obj = {
  f: function() {
    alert(2)
  }
};

with(obj) {
  f();
}

////////////////////////////////////////////////////////////////

/*#106*/

/*Конструкция with не создаёт области видимости, её создают только функции. Поэтому объявление var b внутри конструкции работает также, как если бы оно было вне её.

Код в задаче эквивалентен такому:*/

var a = 1;
var b;

var obj = {
  b: 2
}

with(obj) {
  alert( a + b );
}

////////////////////////////////////////////////////////////////

/*#107*/

/*Вызов arr[2]() – это обращение к методу объекта obj[method](), в роли obj выступает arr, а в роли метода: 2.

Поэтому, как это бывает при вызове функции как метода, функция arr[2] получит this = arr и выведет массив:*/

 var arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // "a","b",function

////////////////////////////////////////////////////////////////

/*#108*/

/*Ошибка!

Попробуйте:*/

 var obj = {
  go: function() {
    alert(this)
  }
}

(obj.go)() // error!
/*Причем сообщение об ошибке в большинстве браузеров не даёт понять, что на самом деле не так.

Ошибка возникла из-за того, что после объявления obj пропущена точка с запятой.

JavaScript игнорирует перевод строки перед скобкой (obj.go)() и читает этот код как:
*/
var obj = { go:... }(obj.go)()
//Интерпретатор попытается вычислить это выражение, которое обозначает вызов объекта { go: ... } как функции с аргументом (obj.go). При этом, естественно, возникнет ошибка.

////////////////////////////////////////////////////////////////

/*#109*/

/*1. Обычный вызов функции в контексте объекта.

2. То же самое, скобки ни на что не влияют.

3. Здесь не просто вызов obj.method(), а более сложный вызов вида (выражение).method(). Такой вызов работает, как если бы он был разбит на две строки:

f = obj.go; // сначала вычислить выражение
f();             // потом вызвать то, что получилось
При этом f() выполняется как обычная функция, без передачи this.

4. Здесь также слева от точки находится выражение, вызов аналогичен двум строкам.

В спецификации это объясняется при помощи специального внутреннего типа Reference Type.

Если подробнее – то obj.go() состоит из двух операций:

Сначала получить свойство obj.go.
Потом вызвать его как функцию.
Но откуда на шаге 2 получить this? Как раз для этого операция получения свойства obj.go возвращает значение особого типа Reference Type, который в дополнение к свойству go содержит информацию об obj. Далее, на втором шаге, вызов его при помощи скобок () правильно устанавливает this.

Любые другие операции, кроме вызова, превращают Reference Type в обычный тип, в данном случае – функцию go (так уж этот тип устроен).

Поэтому получается, что (method = obj.go) присваивает в переменную method функцию go, уже без всякой информации об объекте obj.

Аналогичная ситуация и в случае (4): оператор ИЛИ || делает из Reference Type обычную функцию.*/

////////////////////////////////////////////////////////////////

/*#110*/

//Ответ: undefined.

var user = {
  firstName: "Василий",

  export: this // (*)
};

alert( user.export.firstName );
//Объявление объекта само по себе не влияет на this. Никаких функций, которые могли бы повлиять на контекст, здесь нет.

//Так как код находится вообще вне любых функций, то this в нём равен window (в браузере так всегда для кода вне функций, вне зависимости от use strict).

//Получается, что в строке (*) мы имеем export: window, так что далее alert(user.export.firstName) выводит свойство window.firstName, которое не определено.

////////////////////////////////////////////////////////////////

/*#111*/

/*Ответ: Василий.

Вызов user.export() использует this, который равен объекту до точки, то есть внутри user.export() строка return this возвращает объект user.

В итоге выводится свойство name объекта user, равное "Василий".*/

////////////////////////////////////////////////////////////////

/*#112*/

/*Ответ: Василий.

Во время выполнения user.export() значение this = user.

При создании объекта { value: this }, в свойство value копируется ссылка на текущий контекст, то есть на user.

Получается что user.export().value == user.*/

 var name = "";

var user = {
  name: "Василий",

  export: function() {
    return {
      value: this
    };
  }

};

alert( user.export().value == user ); // true

////////////////////////////////////////////////////////////////

/*#113*/

var calculator = {
  sum: function() {
    return this.a + this.b;
  },

  mul: function() {
    return this.a * this.b;
  },

  read: function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
}

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );

////////////////////////////////////////////////////////////////

/*#114*/

//Решение состоит в том, чтобы каждый раз возвращать текущий объект. Это делается добавлением return this в конце каждого метода:

 var ladder = {
  step: 0,
  up: function() {
    this.step++;
    return this;
  },
  down: function() {
    this.step--;
    return this;
  },
  showStep: function() {
    alert( this.step );
    return this;
  }
}

ladder.up().up().down().up().down().showStep(); // 1

////////////////////////////////////////////////////////////////

/*#115*/

/*Если с одной стороны – объект, а с другой – нет, то сначала приводится объект.

В данном случае сравнение означает численное приведение. У массивов нет valueOf, поэтому вызывается toString, который возвращает список элементов через запятую.

В данном случае, элемент только один – он и возвращается. Так что ['x'] становится 'x'. Получилось 'x' == 'x', верно.

P.S. По той же причине верны равенства:*/

 alert( ['x', 'y'] == 'x,y' ); // true
alert( [] == '' ); // true

////////////////////////////////////////////////////////////////

/*#116*/

/*Первый alert(foo)
Возвращает строковое представление объекта, используя toString, т.е. "foo".

Второй alert(foo + 1)
Оператор '+' преобразует объект к примитиву, используя valueOf, так что результат: 3.

Третий alert(foo + „3“)
То же самое, что и предыдущий случай, объект превращается в примитив 2. Затем происходит сложение 2 + '3'. Оператор '+' при сложении чего-либо со строкой приводит и второй операнд к строке, а затем применяет конкатенацию, так что результат – строка "23".*/

////////////////////////////////////////////////////////////////

/*#117*/

/*Ответ по первому равенству
Два объекта равны только тогда, когда это один и тот же объект.*/

//В первом равенстве создаются два массива, это разные объекты, так что они неравны.

//Ответ по второму равенству
//Первым делом, обе части сравнения вычисляются. Справа находится ![]. Логическое НЕ '!' преобразует аргумент к логическому типу. Массив является объектом, так что это true. Значит, правая часть становится ![] = !true = false. Так что получили:

alert( [] == false );
//Проверка равенства между объектом и примитивом вызывает численное преобразование объекта.

//У массива нет valueOf, сработает toString и преобразует массив в список элементов, то есть – в пустую строку:

alert( '' == false );
//Сравнение различных типов вызывает численное преобразование слева и справа:

alert( 0 == 0 );
//Теперь результат очевиден.

////////////////////////////////////////////////////////////////

/*#118*/

new Date(0) - 0 = 0 // (1)
new Array(1)[0] + "" = "undefined" // (2)
({})[0] = undefined // (3)
[1] + 1 = "11" // (4)
[1,2] + [3,4] = "1,23,4" // (5)
[] + null + 1 = "null1" // (6)
[[0]][0][0] = 0 // (7)
({} + {}) = "[object Object][object Object]" // (8)
new Date(0) //– дата, созданная по миллисекундам и соответствующая 0 мс от 1 января 1970 года 00:00:00 UTC. Оператор минус - преобразует дату обратно в число миллисекунд, то есть в 0.

new Array(num) //при вызове с единственным аргументом-числом создаёт массив данной длины, без элементов. Поэтому его нулевой элемент равен undefined, при сложении со строкой получается строка "undefined".

/*Фигурные скобки – это создание пустого объекта, у него нет свойства '0'. Так что значением будет undefined. Обратите внимание на внешние, круглые скобки. Если их убрать и запустить {}[0] в отладочной консоли браузера – будет 0, т.к. скобки {} будут восприняты как пустой блок кода, после которого идёт массив.

Массив преобразуется в строку "1". Оператор "+" при сложении со строкой приводит второй аргумент к строке – значит будет "1" + "1" = "11".

Массивы приводятся к строке и складываются.

Массив преобразуется в пустую строку "" + null + 1, оператор "+" видит, что слева строка и преобразует null к строке, получается "null" + 1, и в итоге "null1".

[[0]] – это вложенный массив [0] внутри внешнего [ ]. Затем мы берём от него нулевой элемент, и потом еще раз.

Если это непонятно, то посмотрите на такой пример:*/

alert( [1,[0],2][1] );
//Квадратные скобки после массива/объекта обозначают не другой массив, а взятие элемента.

//Каждый объект преобразуется к примитиву. У встроенных объектов Object нет подходящего valueOf, поэтому используется toString, так что складываются в итоге строковые представления объектов.

////////////////////////////////////////////////////////////////

/*#119*/

/*Подсказка
Чтобы sum(1), а также sum(1)(2) можно было вызвать новыми скобками – результатом sum должна быть функция.

Но эта функция также должна уметь превращаться в число. Для этого нужно дать ей соответствующий valueOf. А если мы хотим, чтобы и в строковом контексте она вела себя так же – то toString.

Решение
Функция, которая возвращается sum, должна накапливать значение при каждом вызове.

Удобнее всего хранить его в замыкании, в переменной currentSum. Каждый вызов прибавляет к ней очередное значение:*/

 function sum(a) {

  var currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1)(2) ); // 6
alert( sum(6)(-1)(-2)(-3) ); // 0
alert( sum(0)(1)(2)(3)(4)(5) ); // 15
/*При внимательном взгляде на решение легко заметить, что функция sum срабатывает только один раз. Она возвращает функцию f.

Затем, при каждом запуске функция f добавляет параметр к сумме currentSum, хранящейся в замыкании, и возвращает сама себя.

В последней строчке f нет рекурсивного вызова.

Вот так была бы рекурсия:*/

function f(b) {
  currentSum += b;
  return f(); // <-- подвызов
}
//А в нашем случае, мы просто возвращаем саму функцию, ничего не вызывая.

function f(b) {
  currentSum += b;
  return f; // <-- не вызывает сама себя, а возвращает ссылку на себя
}
//Эта f используется при следующем вызове, опять возвратит себя, и так сколько нужно раз. Затем, при использовании в строчном или численном контексте – сработает toString, который вернет текущую сумму currentSum.

////////////////////////////////////////////////////////////////

/*#120*/

/*Да, возможны.

Они должны возвращать одинаковый объект. При этом если функция возвращает объект, то this не используется.

Например, они могут вернуть один и тот же объект obj, определённый снаружи:*/

 var obj = {};

function A() { return obj; }
function B() { return obj; }

var a = new A;
var b = new B;

alert( a == b ); // true

////////////////////////////////////////////////////////////////

/*#121*/

function Calculator() {

  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };

  this.sum = function() {
    return this.a + this.b;
  };

  this.mul = function() {
    return this.a * this.b;
  };
}

var calculator = new Calculator();
calculator.read();

alert( "Сумма=" + calculator.sum() );
alert( "Произведение=" + calculator.mul() );

////////////////////////////////////////////////////////////////

/*#122*/

function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('Сколько добавлять будем?', 0);
  };

}

var accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert( accumulator.value );

////////////////////////////////////////////////////////////////

/*#123*/

function Calculator() {

  var methods = {
    "-": function(a, b) {
      return a - b;
    },
    "+": function(a, b) {
      return a + b;
    }
  };

  this.calculate = function(str) {

    var split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2]

    if (!methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return methods[op](a, b);
  }

  this.addMethod = function(name, func) {
    methods[name] = func;
  };
}

var calc = new Calculator;

calc.addMethod("*", function(a, b) {
  return a * b;
});
calc.addMethod("/", function(a, b) {
  return a / b;
});
calc.addMethod("**", function(a, b) {
  return Math.pow(a, b);
});

var result = calc.calculate("2 ** 3");
alert( result ); // 8
//Обратите внимание на хранение методов. Они просто добавляются к внутреннему объекту.
//Все проверки и преобразование к числу производятся в методе calculate. В дальнейшем он может быть расширен для поддержки более сложных выражений.

////////////////////////////////////////////////////////////////

/*#124*/

function User(fullName) {
  this.fullName = fullName;

  Object.defineProperties(this, {

    firstName: {

      get: function() {
        return this.fullName.split(' ')[0];
      },

      set: function(newFirstName) {
        this.fullName = newFirstName + ' ' + this.lastName;
      }

    },

    lastName: {

      get: function() {
        return this.fullName.split(' ')[1];
      },

      set: function(newLastName) {
        this.fullName = this.firstName + ' ' + newLastName;
      }

    }

  });
}

var vasya = new User("Василий Попкин");

// чтение firstName/lastName
alert( vasya.firstName ); // Василий
alert( vasya.lastName ); // Попкин

// запись в lastName
vasya.lastName = 'Сидоров';

alert( vasya.fullName ); // Василий Сидоров

////////////////////////////////////////////////////////////////

/*#125*/

//Решение (как вариант):

function Article() {
  this.created = new Date();

  Article.count++; // увеличиваем счетчик при каждом вызове
  Article.last = this.created; // и запоминаем дату
}
Article.count = 0; // начальное значение
// (нельзя оставить undefined, т.к. Article.count++ будет NaN)

Article.showStats = function() {
  alert( 'Всего: ' + this.count + ', Последняя: ' + this.last );
};

new Article();
new Article();

Article.showStats(); // Всего: 2, Последняя: (дата)

new Article();

Article.showStats(); // Всего: 3, Последняя: (дата)

////////////////////////////////////////////////////////////////

/*#126*/

//Первый вариант
 function sumArgs() {
  // скопируем reduce из массива
  arguments.reduce = [].reduce;
  return arguments.reduce(function(a, b) {
    return a + b;
  });
}

alert( sumArgs(4, 5, 6) ); // 15
//Второй вариант
//Метод call здесь вполне подойдёт, так как требуется вызвать reduce в контексте arguments с одним аргументом.

 function sumArgs() {
  // запустим reduce из массива напрямую
  return [].reduce.call(arguments, function(a, b) {
    return a + b;
  });
}

alert( sumArgs(4, 5, 6) ); // 15

////////////////////////////////////////////////////////////////

/*#127*/

function sum() {
  return [].reduce.call(arguments, function(a, b) {
    return a + b;
  });
}

function mul() {
  return [].reduce.call(arguments, function(a, b) {
    return a * b;
  });
}

function applyAll(func) {
    return func.apply(this, [].slice.call(arguments, 1));
  }

alert( applyAll(sum, 1, 2, 3) ); // 6
alert( applyAll(mul, 2, 3, 4) ); // 24
alert( applyAll(Math.max, 2, -2, 3) ); // 3
alert( applyAll(Math.min, 2, -2, 3) ); // -2

////////////////////////////////////////////////////////////////

/*#128*/

/*Страшновато выглядит, да? Работает так (по строкам):

1. Вызов bind сохраняет дополнительные аргументы args (они идут со 2-го номера) в массив bindArgs.
2. … и возвращает обертку wrapper.
3. Эта обёртка делает из arguments массив args и затем, используя метод concat, прибавляет их к аргументам bindArgs (карринг).
4. Затем передаёт вызов func с контекстом и общим массивом аргументов.*/

////////////////////////////////////////////////////////////////

/*#129*/

//Ответ: Hello.

 function f() {
  alert( this );
}

var user = {
  g: f.bind("Hello")
}

user.g();
/*Так как вызов идёт в контексте объекта user.g(), то внутри функции g контекст this = user.

Однако, функции g совершенно без разницы, какой this она получила.

Её единственное предназначение – это передать вызов в f вместе с аргументами и ранее указанным контекстом "Hello", что она и делает.

Эта задача демонстрирует, что изменить однажды привязанный контекст уже нельзя.*/

////////////////////////////////////////////////////////////////

/*#130*/

//Ответ: "Вася".

 function f() {
  alert(this.name);
}

f = f.bind( {name: "Вася"} ).bind( {name: "Петя"} );

f(); // Вася
/*Первый вызов f.bind(..Вася..) возвращает «обёртку», которая устанавливает контекст для f и передаёт вызов f.

Следующий вызов bind будет устанавливать контекст уже для этой обёртки. Это ни на что не повлияет.

Чтобы это проще понять, используем наш собственный вариант bind вместо встроенного:*/

function bind(func, context) {
  return function() {
    return func.apply(context, arguments);
  };
}
//Код станет таким:

function f() {
  alert(this.name);
}

f = bind(f, {name: "Вася"} ); // (1)
f = bind(f, {name: "Петя"} ); // (2)

f(); // Вася
//Здесь видно, что первый вызов bind, в строке (1), возвращает обёртку вокруг f, которая выглядит так (выделена):

function bind(func, context) {
  return function() {
    // здесь this не используется
    return func.apply(context, arguments);
  };
}
/*В этой обёртке нигде не используется this, контекст context берётся из замыкания. Посмотрите на код, там нигде нет this.

Поэтому следующий bind в строке (2), который выполняется уже над обёрткой и фиксирует в ней this, ни на что не влияет. Какая разница, что будет в качестве this в функции, которая этот this не использует? Контекст context, как видно в коде выше, она получает через замыкание из аргументов первого bind.*/

////////////////////////////////////////////////////////////////

/*#131*/

/*Ответ: undefined.

Результатом работы bind является функция-обёртка над sayHi. Эта функция – самостоятельный объект, у неё уже нет свойства test.*/

////////////////////////////////////////////////////////////////

/*#132*/

//Решение с bind
//Ошибка происходит потому, что ask получает только функцию, без объекта-контекста.

//Используем bind, чтобы передать в ask функцию с уже привязанным контекстом:

"use strict";

function ask(question, answer, ok, fail) {
  var result = prompt(question, '');
  if (result.toLowerCase() == answer.toLowerCase()) ok();
  else fail();
}

var user = {
  login: 'Василий',
  password: '12345',

  loginOk: function() {
    alert( this.login + ' вошёл в сайт' );
  },

  loginFail: function() {
    alert( this.login + ': ошибка входа' );
  },

  checkPassword: function() {
    ask("Ваш пароль?", this.password, this.loginOk.bind(this), this.loginFail.bind(this));
  }
};

var vasya = user;
user = null;
vasya.checkPassword();
/*Решение через замыкание
Альтернативное решение – сделать функции-обёртки над user.loginOk/loginFail:*/

var user = {
  //...
  checkPassword: function() {
    ask("Ваш пароль?", this.password,
      function() { user.loginOk(); }, function() { user.loginFail(); });
  }
}
…//Но такой код использует переменную user, так что если объект переместить из неё, к примеру, так, то работать он не будет:

var vasya = user; // переместим user в vasya
user = null;
vasya.checkPassword(); // упс будет ошибка, ведь в коде объекта остался user
//Для того, чтобы избежать проблем, можно использовать this. Внутри checkPassword он всегда будет равен текущему объекту, так что скопируем его в переменную, которую назовём self:

"use strict";

function ask(question, answer, ok, fail) {
  var result = prompt(question, '');
  if (result.toLowerCase() == answer.toLowerCase()) ok();
  else fail();
}

var user = {
  login: 'Василий',
  password: '12345',

  loginOk: function() {
    alert( this.login + ' вошёл в сайт' );
  },

  loginFail: function() {
    alert( this.login + ': ошибка входа' );
  },

  checkPassword: function() {
    var self = this;
    ask("Ваш пароль?", this.password,
      function() {
        self.loginOk();
      },
      function() {
        self.loginFail();
      }
    );
  }
};

var vasya = user;
user = null;
vasya.checkPassword();
//Теперь всё работает. Анонимные функции достают правильный контекст из замыкания, где он сохранён в переменной self.

////////////////////////////////////////////////////////////////

/*#133*/

/*Решение с bind
Первое решение – передать в ask функции с привязанным контекстом и аргументами.*/

"use strict";

function ask(question, answer, ok, fail) {
  var result = prompt(question, '');
  if (result.toLowerCase() == answer.toLowerCase()) ok();
  else fail();
}

var user = {
  login: 'Василий',
  password: '12345',

  loginDone: function(result) {
    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );
  },

  checkPassword: function() {
    ask("Ваш пароль?", this.password, this.loginDone.bind(this, true), this.loginDone.bind(this, false));
  }
};

user.checkPassword();
/*Решение с локальной переменной
Второе решение – это скопировать this в локальную переменную (чтобы внешняя перезапись не повлияла):*/

"use strict";

function ask(question, answer, ok, fail) {
  var result = prompt(question, '');
  if (result.toLowerCase() == answer.toLowerCase()) ok();
  else fail();
}

var user = {
  login: 'Василий',
  password: '12345',

  loginDone: function(result) {
    alert( this.login + (result ? ' вошёл в сайт' : ' ошибка входа') );
  },

  checkPassword: function() {
    var self = this;
    ask("Ваш пароль?", this.password,
      function() {
        self.loginDone(true);
      },
      function() {
        self.loginDone(false);
      }
    );
  }
};

user.checkPassword();
//Оба решения хороши, вариант с bind короче.

////////////////////////////////////////////////////////////////

/*#134*/

//Возвратим декоратор wrapper который будет записывать аргумент в log и передавать вызов в f:

function work(a) {
  /*...*/ // work - произвольная функция, один аргумент
}

function makeLogging(f, log) {

  function wrapper(a) {
      log.push(a);
      return f.call(this, a);
    }

  return wrapper;
}

var log = [];
work = makeLogging(work, log);

work(1); // 1
work(5); // 5

for (var i = 0; i < log.length; i++) {
  alert( 'Лог:' + log[i] ); // "Лог:1", затем "Лог:5"
}
/*Обратите внимание, вызов функции осуществляется как f.call(this, a), а не просто f(a).

Передача контекста необходима, чтобы декоратор корректно работал с методами объекта. Например:*/

user.method = makeLogging(user.method, log);
//Теперь при вызове user.method(...) в декоратор будет передаваться контекст this, который надо передать исходной функции через call/apply.

////////////////////////////////////////////////////////////////

/*#135*/

/*Решение аналогично задаче Логирующий декоратор (1 аргумент), разница в том, что в лог вместо одного аргумента идет весь объект arguments.

Для передачи вызова с произвольным количеством аргументов используем f.apply(this, arguments).*/

function work(a, b) {
  alert( a + b ); // work - произвольная функция
}

function makeLogging(f, log) {

  function wrapper() {
      log.push([].slice.call(arguments));
      return f.apply(this, arguments);
    }

  return wrapper;
}

var log = [];
work = makeLogging(work, log);

work(1, 2); // 3
work(4, 5); // 9

for (var i = 0; i < log.length; i++) {
  var args = log[i]; // массив из аргументов i-го вызова
  alert( 'Лог:' + args.join() ); // "Лог:1,2", "Лог:4,5"
}

////////////////////////////////////////////////////////////////

/*#136*/

//Запоминать результаты вызова функции будем в замыкании, в объекте cache: { ключ:значение }.

function f(x) {
  return Math.random()*x;
}

function makeCaching(f) {
  var cache = {};

  return function(x) {
    if (!(x in cache)) {
      cache[x] = f.call(this, x);
    }
    return cache[x];
  };

}

f = makeCaching(f);

var a = f(1);
var b = f(1);
alert( a == b ); // true (значение закешировано)

b = f(2);
alert( a == b ); // false, другой аргумент => другое значение
/*Обратите внимание: проверка на наличие уже подсчитанного значения выглядит так: if (x in cache). Менее универсально можно проверить так: if (cache[x]), это если мы точно знаем, что cache[x] никогда не будет false, 0 и т.п.

Открыть решение с тестами в песочнице.*/

////////////////////////////////////////////////////////////////

/*#137*/

/*Для определения примитивного типа строка/число подойдет оператор typeof.

Примеры его работы:*/

 alert( typeof 123 ); // "number"
alert( typeof "строка" ); // "string"
alert( typeof new Date() ); // "object"
alert( typeof [] ); // "object"
/*Оператор typeof не умеет различать разные типы объектов, они для него все на одно лицо: "object". Поэтому он не сможет отличить Date от Array.

Для отличия Array используем вызов Array.isArray. Если он неверен, значит у нас дата.*/

////////////////////////////////////////////////////////////////

/*#138*/

var leader = {
  name: "Василий Иванович",
  age: 35
};

var leaderStr = JSON.stringify(leader);
leader = JSON.parse(leaderStr);

////////////////////////////////////////////////////////////////

/*#139*/

/*Ответ на первый вопрос
Обычный вызов JSON.stringify(team) выдаст ошибку, так как объекты leader и soldier внутри структуры ссылаются друг на друга.

Формат JSON не предусматривает средств для хранения ссылок.

Варианты решения
Чтобы превращать такие структуры в JSON, обычно используются два подхода:

Добавить в team свой код toJSON:*/

team.toJSON = function() {
  /* свой код, который может создавать копию объекта без круговых ссылок и передавать управление JSON.stringify */
}
/*При этом, конечно, понадобится и своя функция чтения из JSON, которая будет восстанавливать объект, а затем дополнять его круговыми ссылками.

Можно учесть возможную проблему в самой структуре, используя вместо ссылок id. Как правило, это несложно, ведь на сервере у данных тоже есть идентификаторы.

Изменённая структура может выглядеть так:*/

var leader = {
  id: 12,
  name: "Василий Иванович"
};

var soldier = {
  id: 51,
  name: "Петька"
};

// поменяли прямую ссылку на ID
leader.soldierId = 51;
soldier.leaderId = 12;

var team = {
  12: leader,
  51: soldier
};
/*…Но действительно ли это решение будет оптимальным? Использовать структуру стало сложнее, и вряд ли это изменение стоит делать лишь из-за JSON. Вот если есть другие преимущества, тогда можно подумать.

Универсальный вариант подхода, описанного выше – это использование особой реализации JSON, которая не входит в стандарт и поддерживает расширенный формат для поддержки ссылок.

Она, к примеру, есть во фреймворке Dojo.

При вызове dojox.json.ref.toJson(team) будет создано следующее строковое представление:*/

[{"name":"Василий Иванович","soldier":{"name":"Петька","leader":{"$ref":"#0"}}},{"$ref":"#0.soldier"}]
//Метод разбора такой строки – также свой: dojox.json.ref.fromJson.

////////////////////////////////////////////////////////////////

/*#139*/

function printNumbersInterval() {
  var i = 1;
  var timerId = setInterval(function() {
    console.log(i);
    if (i == 20) clearInterval(timerId);
    i++;
  }, 100);
}

// вызов
printNumbersInterval();

////////////////////////////////////////////////////////////////

/*#140*/

function printNumbersTimeout20_100() {
  var i = 1;
  var timerId = setTimeout(function go() {
    console.log(i);
    if (i < 20) setTimeout(go, 100);
    i++;
  }, 100);
}

// вызов
printNumbersTimeout20_100();

////////////////////////////////////////////////////////////////

/*#141*/

/*Нужно выбрать вариант 2, который гарантирует браузеру свободное время между выполнениями highlight.

Первый вариант может загрузить процессор на 100%, если highlight занимает время, близкое к 10 мс или, тем более, большее чем 10 мс, т.к. таймер не учитывает время выполнения функции.

Что интересно, в обоих случаях браузер не будет выводить предупреждение о том, что скрипт занимает много времени. Но от 100% загрузки процессора возможны притормаживания других операций. В общем, это совсем не то, что мы хотим, поэтому вариант 2.*/

////////////////////////////////////////////////////////////////

/*#142*/

/*Ответы:

alert выведет 100000000.
3, срабатывание будет после окончания работы hardWork.
Так будет потому, что вызов планируется на 100 мс от времени вызова setTimeout, но функция выполняется больше, чем 100 мс, поэтому к моменту ее окончания время уже подошло и отложенный вызов выполняется тут же.*/

////////////////////////////////////////////////////////////////

/*#143*/

/*Вызов alert(i) в setTimeout введет 100000001.

Можете проверить это запуском:*/

var timer = setInterval(function() {
  i++;
}, 10);

setTimeout(function() {
  clearInterval(timer);
  alert( i ); // (*)
}, 50);

var i;

function f() {
  // точное время выполнения не играет роли
  // здесь оно заведомо больше 100 мс
  for (i = 0; i < 1e8; i++) f[i % 2] = i;
}

f();
/*Правильный вариант срабатывания: 3 (сразу же по окончании f один раз).

Планирование setInterval будет вызывать функцию каждые 10 мс после текущего времени. Но так как интерпретатор занят долгой функцией, то до конца ее работы никакого вызова не происходит.

За время выполнения f может пройти время, на которое запланированы несколько вызовов setInterval, но в этом случае остается только один, т.е. накопления вызовов не происходит. Такова логика работы setInterval.

После окончания текущего скрипта интерпретатор обращается к очереди запланированных вызовов, видит в ней setInterval и выполняет. А затем тут же выполняется setTimeout, очередь которого тут же подошла.

Итого, как раз и видим, что setInterval выполнился ровно 1 раз по окончании работы функции. Такое поведение кросс-браузерно.*/

////////////////////////////////////////////////////////////////

/*#144*/

/*Задача – с небольшим «нюансом».

Есть браузеры, в которых на время работы JavaScript таймер «застывает», например таков IE. В них количество шагов будет почти одинаковым, ±1.

В других браузерах (Chrome) первый бегун будет быстрее.

Создадим реальные объекты Runner и запустим их для проверки:*/

 function Runner() {
  this.steps = 0;

  this.step = function() {
    this.doSomethingHeavy();
    this.steps++;
  };

  function fib(n) {
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
  }

  this.doSomethingHeavy = function() {
    for (var i = 0; i < 25; i++) {
      this[i] = fib(i);
    }
  };

}

var runner1 = new Runner();
var runner2 = new Runner();

// запускаем бегунов
var t1 = setInterval(function() {
  runner1.step();
}, 15);

var t2 = setTimeout(function go() {
  runner2.step();
  t2 = setTimeout(go, 15);
}, 15);

// кто сделает больше шагов?
setTimeout(function() {
  clearInterval(t1);
  clearTimeout(t2);
  alert( runner1.steps );
  alert( runner2.steps );
}, 5000);
/*Если бы в шаге step() не было вызова doSomethingHeavy(), то есть он бы не требовал времени, то количество шагов было бы почти равным.

Но так как у нас шаг, всё же, что-то делает, и функция doSomethingHeavy() специально написана таким образом, что она требует (небольшого) времени, то первый бегун успеет сделать больше шагов. Ведь в setTimeout пауза 15 мс будет между шагами, а setInterval шагает равномерно, каждые 15 мс. Получается чаще.

////////////////////////////////////////////////////////////////

/*#145*/

function delay(f, ms) {

  return function() {
    var savedThis = this;
    var savedArgs = arguments;

    setTimeout(function() {
      f.apply(savedThis, savedArgs);
    }, ms);
  };

}

function f(x) {
  alert( x );
}

var f1000 = delay(f, 1000);
var f1500 = delay(f, 1500);

f1000("тест"); // выведет "тест" через 1000 миллисекунд
f1500("тест2"); // выведет "тест2" через 1500 миллисекунд
//Обратим внимание на то, как работает обёртка:

return function() {
  var savedThis = this;
  var savedArgs = arguments;

  setTimeout(function() {
    f.apply(savedThis, savedArgs);
  }, ms);
};
/*Именно обёртка возвращается декоратором delay и будет вызвана. Чтобы передать аргумент и контекст функции, вызываемой через ms миллисекунд, они копируются в локальные переменные savedThis и savedArgs.

Это один из самых простых, и в то же время удобных способов передать что-либо в функцию, вызываемую через setTimeout.*/

////////////////////////////////////////////////////////////////

/*#146*/

function debounce(f, ms) {

  let timer = null;

  return function (...args) {
    const onComplete = () => {
      f.apply(this, args);
      timer = null;
    }

    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(onComplete, ms);
  };
}

function f(x) { alert(x) }
let f = debounce(f, 1000);

f(1); // вызов отложен на 1000 мс
f(2); // предыдущий отложенный вызов игнорируется, текущий (2) откладывается на 1000 мс

// через 1 секунду появится alert(2)

setTimeout( function() { f(3) }, 1100); // через 1100 мс отложим вызов еще на 1000 мс
setTimeout( function() { f(4) }, 1200); // игнорируем вызов (3)

// через 2200 мс от начала выполнения появится alert(4)
/*Вызов debounce возвращает функцию-обёртку. Все необходимые данные для неё хранятся в замыкании.

При первом вызове обертки в значении переменной timer находится null и происходит вызов setTimeout.

Этот вызов во-первых отложит выполнение декорируемой функции на ms миллисекунд, а во-вторых установит в качестве значения time числовой идентификатор, который позволит обнулить отложенное задание при последующих вызовах.*/

////////////////////////////////////////////////////////////////

/*#147*/

function throttle(func, ms) {

  var isThrottled = false,
    savedArgs,
    savedThis;

  function wrapper() {

    if (isThrottled) { // (2)
      savedArgs = arguments;
      savedThis = this;
      return;
    }

    func.apply(this, arguments); // (1)

    isThrottled = true;

    setTimeout(function() {
      isThrottled = false; // (3)
      if (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = null;
      }
    }, ms);
  }

  return wrapper;
}
/*Шаги работы этой функции:

Декоратор throttle возвращает функцию-обёртку wrapper, которая при первом вызове запускает func и переходит в состояние «паузы» (isThrottled = true).
В этом состоянии все новые вызовы запоминаются в замыкании через savedArgs/savedThis. Обратим внимание, что и контекст вызова и аргументы для нас одинаково важны и запоминаются одновременно. Только зная и то и другое, можно воспроизвести вызов правильно.
Далее, когда пройдёт таймаут ms миллисекунд – пауза будет снята, а wrapper – запущен с последними аргументами и контекстом (если во время паузы были вызовы).
Шаг (3) запускает именно не саму функцию, а снова wrapper, так как необходимо не только выполнить func, но и снова поставить выполнение на паузу. Получается последовательность «вызов – пауза… вызов – пауза … вызов – пауза …», каждое выполнение в обязательном порядке сопровождается паузой после него. Это удобно описывается рекурсией.*/

////////////////////////////////////////////////////////////////

/*#148*/

/*Вычислить любое выражение нам поможет eval:*/

 var expr = prompt("Введите выражение?", '2*3+2');

alert( eval(expr) );
/*При этом посетитель потенциально может делать все, что угодно.

Чтобы ограничить выражения только математикой, вводимую строку нужно проверять при помощи регулярных выражений на наличие любых символов, кроме букв, пробелов и знаков пунктуации.*/

////////////////////////////////////////////////////////////////

/*#149*/

/*Разница в поведении станет очевидной, если рассмотреть код внутри функции.

Поведение будет различным, если управление каким-то образом выпрыгнет из try..catch.

Например, finally сработает после return, но до передачи управления внешнему коду:*/

function f() {
  try {
    ...
    return result;
  } catch (e) {
    ...
  } finally {
    очистить ресурсы
  }
}
//Или же управление может выпрыгнуть из-за throw:

function f() {
  try {
    //...

  } catch (e) {
   // ...
    if(не умею обрабатывать эту ошибку) {
      throw e;
    }

  } finally {
   // очистить ресурсы
  }
}
//В этих случаях именно finally гарантирует выполнение кода до окончания работы f, просто код не будет вызван.

////////////////////////////////////////////////////////////////

/*#150*/

//Вычислить любое выражение нам поможет eval:

 alert( eval("2+2") ); // 4
/*Считываем выражение в цикле while(true). Если при вычислении возникает ошибка – ловим её в try..catch.

Ошибкой считается, в том числе, получение NaN из eval, хотя при этом исключение не возникает. Можно бросить своё исключение в этом случае.

Код решения:*/

 var expr, res;

while (true) {
  expr = prompt("Введите выражение?", '2-');
  if (expr == null) break;

  try {
    res = eval(expr);
    if (isNaN(res)) {
      throw new Error("Результат неопределён");
    }

    break;
  } catch (e) {
    alert( "Ошибка: " + e.message + ", повторите ввод" );
  }
}

alert( res );

////////////////////////////////////////////////////////////////

/*#151*/

//Кофеварка с новым методом:

function CoffeeMachine(power) {
  this.waterAmount = 0;

  var WATER_HEAT_CAPACITY = 4200;
  var timerId;
  var self = this;

  function getBoilTime() {
    return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;
  }

  function onReady() {
    alert( 'Кофе готово!' );
  }

  this.run = function() {
    timerId = setTimeout(onReady, getBoilTime());
  };

  this.stop = function() {
    clearTimeout(timerId)
  };
}

var coffeeMachine = new CoffeeMachine(50000);
coffeeMachine.waterAmount = 200;

coffeeMachine.run();
coffeeMachine.stop(); // кофе приготовлен не будет

////////////////////////////////////////////////////////////////

/*#152*/

//Решение:

 function User() {

  var firstName, surname;

  this.setFirstName = function(newFirstName) {
    firstName = newFirstName;
  };

  this.setSurname = function(newSurname) {
    surname = newSurname;
  };

  this.getFullName = function() {
    return firstName + ' ' + surname;
  }
}

var user = new User();
user.setFirstName("Петя");
user.setSurname("Иванов");

alert( user.getFullName() ); // Петя Иванов
//Обратим внимание, что для «геттера» getFullName нет соответствующего свойства объекта, он конструирует ответ «на лету». Это нормально. Одна из целей существования геттеров/сеттеров – как раз и есть изоляция внутренних свойств объекта, чтобы можно было их как угодно менять, генерировать «на лету», а внешний интерфейс оставался тем же.

////////////////////////////////////////////////////////////////

/*#153*/

function CoffeeMachine(power, capacity) {
  //...
  this.setWaterAmount = function(amount) {
    if (amount < 0) {
      throw new Error("Значение должно быть положительным");
    }
    if (amount > capacity) {
      throw new Error("Нельзя залить воды больше, чем " + capacity);
    }

    waterAmount = amount;
  };

  this.getWaterAmount = function() {
    return waterAmount;
  };

  this.getPower = function() {
    return power;
  };
}

////////////////////////////////////////////////////////////////

/*#154*/

//В решении ниже addWater будет просто вызывать setWaterAmount.

function CoffeeMachine(power, capacity) {
  var waterAmount = 0;

  var WATER_HEAT_CAPACITY = 4200;

  function getTimeToBoil() {
    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;
  }

  this.setWaterAmount = function(amount) {
    if (amount < 0) {
      throw new Error("Значение должно быть положительным");
    }
    if (amount > capacity) {
      throw new Error("Нельзя залить больше, чем " + capacity);
    }

    waterAmount = amount;
  };

  this.addWater = function(amount) {
    this.setWaterAmount(waterAmount + amount);
  };

  function onReady() {
    alert( 'Кофе готов!' );
  }

  this.run = function() {
    setTimeout(onReady, getTimeToBoil());
  };

}

var coffeeMachine = new CoffeeMachine(100000, 400);
coffeeMachine.addWater(200);
coffeeMachine.addWater(100);
coffeeMachine.addWater(300); // Нельзя залить больше..
coffeeMachine.run();

////////////////////////////////////////////////////////////////

/*#155*/

function CoffeeMachine(power, capacity) {
  var waterAmount = 0;

  var WATER_HEAT_CAPACITY = 4200;

  function getTimeToBoil() {
    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;
  }

  this.setWaterAmount = function(amount) {
    // ... проверки пропущены для краткости
    waterAmount = amount;
  };

  this.getWaterAmount = function(amount) {
    return waterAmount;
  };

  function onReady() {
    alert( 'Кофе готов!' );
  }

  this.setOnReady = function(newOnReady) {
    onReady = newOnReady;
  };

  this.run = function() {
    setTimeout(function() {
      onReady();
    }, getTimeToBoil());
  };

}

var coffeeMachine = new CoffeeMachine(20000, 500);
coffeeMachine.setWaterAmount(150);

coffeeMachine.run();

coffeeMachine.setOnReady(function() {
  var amount = coffeeMachine.getWaterAmount();
  alert( 'Готов кофе: ' + amount + 'мл' ); // Готов кофе: 150 мл
});
//Обратите внимание на два момента в решении:

//В сеттере setOnReady параметр называется newOnReady. Мы не можем назвать его onReady, так как тогда изнутри сеттера мы никак не доберёмся до внешнего (старого значения):

// нерабочий вариант
this.setOnReady = function(onReady) {
  onReady = onReady; // ??? внешняя переменная onReady недоступна
};
//Чтобы setOnReady можно было вызывать в любое время, в setTimeout передаётся не onReady, а анонимная функция function() { onReady() }, которая возьмёт текущий (установленный последним) onReady из замыкания.

////////////////////////////////////////////////////////////////

/*#156*/

//Код решения модифицирует функцию run и добавляет приватный идентификатор таймера timerId, по наличию которого мы судим о состоянии кофеварки:

function CoffeeMachine(power, capacity) {
  var waterAmount = 0;

  var timerId;

  this.isRunning = function() {
    return !!timerId;
  };

  var WATER_HEAT_CAPACITY = 4200;

  function getTimeToBoil() {
    return waterAmount * WATER_HEAT_CAPACITY * 80 / power;
  }

  this.setWaterAmount = function(amount) {
    // ... проверки пропущены для краткости
    waterAmount = amount;
  };

  this.getWaterAmount = function(amount) {
    return waterAmount;
  };

  function onReady() {
    alert( 'Кофе готов!' );
  }

  this.setOnReady = function(newOnReady) {
    onReady = newOnReady;
  };

  this.run = function() {
    timerId = setTimeout(function() {
      timerId = null;
      onReady();
    }, getTimeToBoil());
  };

}

var coffeeMachine = new CoffeeMachine(20000, 500);
coffeeMachine.setWaterAmount(100);

alert( 'До: ' + coffeeMachine.isRunning() ); // До: false

coffeeMachine.run();
alert( 'В процессе: ' + coffeeMachine.isRunning() ); // В процессе: true

coffeeMachine.setOnReady(function() {
  alert( "После: " + coffeeMachine.isRunning() ); // После: false
});

////////////////////////////////////////////////////////////////

/*#157*/

//Изменения в методе run:

this.run = function() {
  if (!this._enabled) {
    throw new Error("Кофеварка выключена");
  }

  setTimeout(onReady, 1000);
};

////////////////////////////////////////////////////////////////

/*#158*/

function Machine(power) {
      this._enabled = false;

      this.enable = function() {
        this._enabled = true;
      };

      this.disable = function() {
        this._enabled = false;
      };
    }

    function CoffeeMachine(power) {
      Machine.apply(this, arguments);

      var waterAmount = 0;
      var timerId;

      this.setWaterAmount = function(amount) {
        waterAmount = amount;
      };

      function onReady() {
        alert('Кофе готов!');
      }

      var parentDisable = this.disable;
      this.disable = function() {
        parentDisable.call(this);
        clearTimeout(timerId);
      }

      this.run = function() {
        if (!this._enabled) {
          throw new Error("Кофеварка выключена");
        }
        timerId = setTimeout(onReady, 1000);
      };

    }

    var coffeeMachine = new CoffeeMachine(10000);
    coffeeMachine.enable();
    coffeeMachine.run();
    coffeeMachine.disable(); // остановит работу, ничего не выведет

////////////////////////////////////////////////////////////////

/*#159*/

function Fridge(power) {
  // унаследовать
  Machine.apply(this, arguments);

  var food = []; // приватное свойство food

  this.addFood = function() {
    if (!this._enabled) {
      throw new Error("Холодильник выключен");
    }
    if (food.length + arguments.length > this._power / 100) {
      throw new Error("Нельзя добавить, не хватает мощности");
    }
    for (var i = 0; i < arguments.length; i++) {
      food.push(arguments[i]); // добавить всё из arguments
    }
  };

  this.getFood = function() {
    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food
    return food.slice();
  };

}

////////////////////////////////////////////////////////////////

/*#160*/

function Machine(power) {
  this._power = power;
  this._enabled = false;

  var self = this;

  this.enable = function() {
    self._enabled = true;
  };

  this.disable = function() {
    self._enabled = false;
  };
}

function Fridge(power) {
  // унаследовать
  Machine.apply(this, arguments);

  var food = []; // приватное свойство food

  this.addFood = function() {
    if (!this._enabled) {
      throw new Error("Холодильник выключен");
    }
    if (food.length + arguments.length >= this._power / 100) {
      throw new Error("Нельзя добавить, не хватает мощности");
    }
    for (var i = 0; i < arguments.length; i++) {
      food.push(arguments[i]); // добавить всё из arguments
    }

  };

  this.getFood = function() {
    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food
    return food.slice();
  };

  this.filterFood = function(filter) {
    return food.filter(filter);
  };

  this.removeFood = function(item) {
    var idx = food.indexOf(item);
    if (idx != -1) food.splice(idx, 1);
  };
}

var fridge = new Fridge(500);
fridge.enable();
fridge.addFood({
  title: "котлета",
  calories: 100
});
fridge.addFood({
  title: "сок",
  calories: 30
});
fridge.addFood({
  title: "зелень",
  calories: 10
});
fridge.addFood({
  title: "варенье",
  calories: 150
});

var dietItems = fridge.filterFood(function(item) {
  return item.calories < 50;
});

fridge.removeFood("нет такой еды"); // без эффекта
alert( fridge.getFood().length ); // 4

dietItems.forEach(function(item) {
  alert( item.title ); // сок, зелень
  fridge.removeFood(item);
});

alert( fridge.getFood().length ); // 2

////////////////////////////////////////////////////////////////

/*#161*/

function Machine(power) {
  this._power = power;
  this._enabled = false;

  var self = this;

  this.enable = function() {
    self._enabled = true;
  };

  this.disable = function() {
    self._enabled = false;
  };
}

function Fridge(power) {
  Machine.apply(this, arguments);

  var food = []; // приватное свойство food

  this.addFood = function() {
    if (!this._enabled) {
      throw new Error("Холодильник выключен");
    }
    if (food.length + arguments.length >= this._power / 100) {
      throw new Error("Нельзя добавить, не хватает мощности");
    }
    for (var i = 0; i < arguments.length; i++) {
      food.push(arguments[i]); // добавить всё из arguments
    }

  };

  this.getFood = function() {
    // копируем еду в новый массив, чтобы манипуляции с ним не меняли food
    return food.slice();
  };

  this.filterFood = function(filter) {
    return food.filter(filter);
  };

  this.removeFood = function(item) {
    var idx = food.indexOf(item);
    if (idx != -1) food.splice(idx, 1);
  };

  var parentDisable = this.disable;
  this.disable = function() {
    if (food.length) {
      throw new Error("Нельзя выключить: внутри еда");
    }
    parentDisable();
  };
}

var fridge = new Fridge(500);
fridge.enable();
fridge.addFood("кус-кус");
fridge.disable(); // ошибка, в холодильнике есть еда

////////////////////////////////////////////////////////////////

/*#162*/

true //, свойство взято из rabbit.
null //свойство взято из animal.
undefined //свойства больше нет.

////////////////////////////////////////////////////////////////

/*#163*/

/*Ответ: свойство будет записано в rabbit.

Если коротко – то потому что this будет указывать на rabbit, а прототип при записи не используется.

Если в деталях – посмотрим как выполняется rabbit.eat():

Интерпретатор ищет rabbit.eat, чтобы его вызвать. Но свойство eat отсутствует в объекте rabbit, поэтому он идет по ссылке rabbit.__proto__ и находит это свойство там.


Функция eat запускается. Контекст ставится равным объекту перед точкой, т.е. this = rabbit.

Итак – получается, что команда this.full = true устанавливает свойство full в самом объекте rabbit. Итог:


Эта задача демонстрирует, что несмотря на то, в каком прототипе находится свойство, это никак не влияет на установку this, которая осуществляется по своим, независимым правилам.*/

////////////////////////////////////////////////////////////////

/*#164*/

//Расставим __proto__:

 var head = {
  glasses: 1
};

var table = {
  pen: 3
};
table.__proto__ = head;

var bed = {
  sheet: 1,
  pillow: 2
};
bed.__proto__ = table;

var pockets = {
  money: 2000
};
pockets.__proto__ = bed;

alert( pockets.pen ); // 3
alert( bed.glasses ); // 1
alert( table.money ); // undefined
//В современных браузерах, с точки зрения производительности, нет разницы, брать свойство из объекта или прототипа. Они запоминают, где было найдено свойство и в следующий раз при запросе, к примеру, pockets.glasses начнут искать сразу в прототипе (head).

////////////////////////////////////////////////////////////////

/*#165*/

/*Результат: true, из прототипа

Результат: true. Свойство prototype всего лишь задаёт __proto__ у новых объектов. Так что его изменение не повлияет на rabbit.__proto__. Свойство eats будет получено из прототипа.

Результат: false. Свойство Rabbit.prototype и rabbit.__proto__ указывают на один и тот же объект. В данном случае изменения вносятся в сам объект.

Результат: true, так как delete rabbit.eats попытается удалить eats из rabbit, где его и так нет. А чтение в alert произойдёт из прототипа.

Результат: undefined. Удаление осуществляется из самого прототипа, поэтому свойство rabbit.eats больше взять неоткуда.*/

////////////////////////////////////////////////////////////////

/*#166*/

//Можно прототипно унаследовать от options и добавлять/менять опции в наследнике:

 function Menu(options) {
  options = Object.create(options);
  options.width = 300;

  alert("width: " + options.width); // возьмёт width из наследника
  alert("height: " + options.height); // возьмёт height из исходного объекта
}

var options = {
  width: 100,
  height: 200
};

var menu = new Menu(options);

alert("original width: " + options.width); // width исходного объекта
alert("original height: " + options.height); // height исходного объекта
//Все изменения будут происходить не в исходном options, а в его наследнике, при этом options останется незатронутым.

////////////////////////////////////////////////////////////////

/*#167*/

/*Первый вызов ставит this == rabbit, остальные ставят this равным Rabbit.prototype, следуя правилу "this – объект перед точкой".

Так что только первый вызов выведет Rabbit, в остальных он будет undefined.

Код для проверки:*/

 function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert( this.name );
};

var rabbit = new Rabbit("Rabbit");

rabbit.sayHi();
Rabbit.prototype.sayHi();
Object.getPrototypeOf(rabbit).sayHi();
rabbit.__proto__.sayHi();
/*Совместимость
Первый вызов работает везде.
Второй вызов работает везде.
Третий вызов не будет работать в IE8-, там нет метода getPrototypeOf
Четвёртый вызов – самый «несовместимый», он не будет работать в IE10-, ввиду отсутствия свойства __proto__.*/

////////////////////////////////////////////////////////////////

/*#168*/

/*Да, можем, но только если уверены, что кто-то позаботился о том, чтобы значение constructor было верным.

В частности, без вмешательства в прототип код точно работает, например:*/

 function User(name) {
  this.name = name;
}

var obj = new User('Вася');
var obj2 = new obj.constructor('Петя');

alert( obj2.name ); // Петя (сработало)
//Сработало, так как User.prototype.constructor == User.

//Но если кто-то, к примеру, перезапишет User.prototype и забудет указать constructor, то такой фокус не пройдёт, например:

function User(name) {
    this.name = name;
  }
User.prototype = {}; // (*)

var obj = new User('Вася');
var obj2 = new obj.constructor('Петя');

alert( obj2.name ); // undefined
/*Почему obj2.name равен undefined? Вот как это работает:

При вызове new obj.constructor('Петя'), obj ищет у себя свойство constructor – не находит.
Обращается к своему свойству __proto__, которое ведёт к прототипу.
Прототипом будет (*), пустой объект.
Далее здесь также ищется свойство constructor – его нет.
Где ищем дальше? Правильно – у следующего прототипа выше, а им будет Object.prototype.
Свойство Object.prototype.constructor существует, это встроенный конструктор объектов, который, вообще говоря, не предназначен для вызова с аргументом-строкой, поэтому создаст совсем не то, что ожидается, но то же самое, что вызов new Object('Петя'), и у такого объекта не будет name.*/

////////////////////////////////////////////////////////////////

/*#169*/

Function.prototype.defer = function(ms) {
  setTimeout(this, ms);
}

function f() {
  alert( "привет" );
}

f.defer(1000); // выведет "привет" через 1 секунду

////////////////////////////////////////////////////////////////

/*#170*/

Function.prototype.defer = function(ms) {
  var f = this;
  return function() {
    var args = arguments,
      context = this;
    setTimeout(function() {
      f.apply(context, args);
    }, ms);
  }
}

// проверка
function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // выведет 3 через 1 секунду.

////////////////////////////////////////////////////////////////

/*#171*/

function CoffeeMachine(power) {
  // свойства конкретной кофеварки
  this._power = power;
  this._waterAmount = 0;
}

// свойства и методы для всех объектов класса
CoffeeMachine.prototype.WATER_HEAT_CAPACITY = 4200;

CoffeeMachine.prototype._getTimeToBoil = function() {
  return this._waterAmount * this.WATER_HEAT_CAPACITY * 80 / this._power;
};

CoffeeMachine.prototype.run = function() {
  setTimeout(function() {
    alert( 'Кофе готов!' );
  }, this._getTimeToBoil());
};

CoffeeMachine.prototype.setWaterAmount = function(amount) {
  this._waterAmount = amount;
};

var coffeeMachine = new CoffeeMachine(10000);
coffeeMachine.setWaterAmount(50);
coffeeMachine.run();

////////////////////////////////////////////////////////////////

/*#172*/

/*Почему возникает проблема
Давайте подробнее разберем происходящее при вызове speedy.found("яблоко"):

Интерпретатор ищет свойство found в speedy. Но speedy – пустой объект, т.к. new Hamster ничего не делает с this.
Интерпретатор идёт по ссылке speedy.__proto__ (==Hamster.prototype) и находят там метод found, запускает его.
Значение this устанавливается в объект перед точкой, т.е. в speedy.
Для выполнения this.food.push() нужно найти свойство this.food. Оно отсутствует в speedy, но есть в speedy.__proto__.
Значение "яблоко" добавляется в speedy.__proto__.food.
У всех хомяков общий живот! Или, в терминах JavaScript, свойство food изменяется в прототипе, который является общим для всех объектов-хомяков.

Заметим, что этой проблемы не было бы при простом присваивании:*/

this.food = something;
/*В этом случае значение записалось бы в сам объект, без поиска found в прототипе.

Проблема возникает только со свойствами-объектами в прототипе.

Для исправления проблемы нужно дать каждому хомяку свой живот. Это можно сделать, присвоив его в конструкторе.*/

function Hamster() {
  this.food = [];
}

Hamster.prototype.found = function(something) {
  this.food.push(something);
};

var speedy = new Hamster();
var lazy = new Hamster();

speedy.found("яблоко");
speedy.found("орех");

alert(speedy.food.length) // 2
alert(lazy.food.length) // 0(!)
//Теперь всё в порядке. У каждого хомяка – свой живот.

////////////////////////////////////////////////////////////////

/*#173*/

//Ошибка в строке:

Rabbit.prototype = Animal.prototype;
/*Эта ошибка приведёт к тому, что Rabbit.prototype и Animal.prototype – один и тот же объект. В результате методы Rabbit будут помещены в него и, при совпадении, перезапишут методы Animal.

Получится, что все животные прыгают, вот пример:*/

function Animal(name) {
  this.name = name;
}

Animal.prototype.walk = function() {
  alert("ходит " + this.name);
};

function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype = Animal.prototype;

Rabbit.prototype.walk = function() {
  alert("прыгает! и ходит: " + this.name);
};

var animal = new Animal("Хрюшка");
animal.walk(); // прыгает! и ходит Хрюшка
//Правильный вариант этой строки:

Rabbit.prototype = Object.create(Animal.prototype);
//Если так написать, то в Rabbit.prototype будет отдельный объект, который прототипно наследует от Animal.prototype, но может содержать и свои свойства, специфичные для кроликов.

////////////////////////////////////////////////////////////////

/*#174*/

/*Ошибка – в том, что метод walk присваивается в конструкторе Animal самому объекту вместо прототипа.

Поэтому, если мы решим перезаписать этот метод своим, специфичным для кролика, то он не сработает:*/

// ...

// записывается в прототип
Rabbit.prototype.walk = function() {
  alert( "прыгает " + this.name );
};
/*Метод this.walk из Animal записывается в сам объект, и поэтому он всегда будет первым, игнорируя цепочку прототипов.

Правильно было бы определять walk как Animal.prototype.walk.

Тем более, что этот метод является общим для всех объектов, тратить память и время на запись его в каждый конструктор определённо ни к чему.*/

////////////////////////////////////////////////////////////////

/*#175*/

function Clock(options) {
  this._template = options.template;
}

Clock.prototype._render = function() {
  var date = new Date();

  var hours = date.getHours();
  if (hours < 10) hours = '0' + hours;

  var min = date.getMinutes();
  if (min < 10) min = '0' + min;

  var sec = date.getSeconds();
  if (sec < 10) sec = '0' + sec;

  var output = this._template.replace('h', hours).replace('m', min).replace('s', sec);

  console.log(output);
};

Clock.prototype.stop = function() {
  clearInterval(this._timer);
};

Clock.prototype.start = function() {
  this._render();
  var self = this;
  this._timer = setInterval(function() {
    self._render();
  }, 1000);
};

////////////////////////////////////////////////////////////////

/*#176*/

//Наследник:

function ExtendedClock(options) {
  Clock.apply(this, arguments);
  this._precision = +options.precision || 1000;
}

ExtendedClock.prototype = Object.create(Clock.prototype);

ExtendedClock.prototype.start = function() {
  this._render();
  var self = this;
  this._timer = setInterval(function() {
    self._render();
  }, this._precision);
};

////////////////////////////////////////////////////////////////

/*#177*/

/*Обратите внимание: константы состояний перенесены в прототип, чтобы AnimatingMenu их тоже унаследовал.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#178*/

/*Нет, не распознает, выведет false.

Свойство constructor содержится в prototype функции по умолчанию, интерпретатор не поддерживает его корректность. Посмотрим, чему оно равно и откуда оно будет взято в данном случае.

Порядок поиска свойства rabbit.constructor, по цепочке прототипов:

rabbit – это пустой объект, в нём нет.
Rabbit.prototype – в него при помощи Object.create записан пустой объект, наследующий от Animal.prototype. Поэтому constructor'а в нём также нет.
Animal.prototype – у функции Animal свойство prototype никто не менял. Поэтому оно содержит Animal.prototype.constructor == Animal.*/
 
function Animal() {}

function Rabbit() {}
Rabbit.prototype = Object.create(Animal.prototype);

var rabbit = new Rabbit();

alert( rabbit.constructor == Rabbit ); // false
alert( rabbit.constructor == Animal ); // true

////////////////////////////////////////////////////////////////

/*#179*/

/*Да, это выглядит достаточно странно, поскольку объект a не создавался функцией B.

Но методу instanceof на самом деле вообще не важна функция. Он смотрит на её prototype и сверяет его с цепочкой __proto__ объекта.

В данном случае a.__proto__ == B.prototype, поэтому instanceof возвращает true.

По логике instanceof именно прототип задаёт «тип объекта», поэтому instanceof работает именно так.*/

////////////////////////////////////////////////////////////////

/*#180*/

/*Да, распознает.

Он проверяет наследование с учётом цепочки прототипов.*/

 function Animal() {}

function Rabbit() {}
Rabbit.prototype = Object.create(Animal.prototype);

var rabbit = new Rabbit();

alert( rabbit instanceof Rabbit ); // true
alert( rabbit instanceof Animal ); // true
alert( rabbit instanceof Object ); // true

////////////////////////////////////////////////////////////////

/*#181*/

function delay(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms);
  });
}

////////////////////////////////////////////////////////////////

/*#182*/

/*Для последовательной загрузки нужно организовать промисы в цепочку, чтобы они выполнялись строго – один после другого.

Вот код, который это делает:*/

// начало цепочки
let chain = Promise.resolve();

let results = [];

// в цикле добавляем задачи в цепочку
urls.forEach(function(url) {
  chain = chain
    .then(() => httpGet(url))
    .then((result) => {
      results.push(result);
    });
});

// в конце — выводим результаты
chain.then(() => {
  alert(results);
});
//Использование Promise.resolve() как начала асинхронной цепочки – очень распространённый приём.

////////////////////////////////////////////////////////////////

/*#183*/

/*Выведет null, так как на момент выполнения скрипта тег <body> ещё не обработан браузером.

Попробуйте в действии:

 <html>

<head>
  <script>
    alert( document.body ); // null
  </script>
</head>

<body>
  Привет, мир!
</body>

</html>*/

////////////////////////////////////////////////////////////////

/*#184*/

//Два способа:

document.documentElement.children[0]
document.documentElement.firstChild
/*Второй способ работает, так как пробелы перед <head> игнорируются.

Также в современных браузерах доступен document.head.

UL
Например, так:*/

document.body.children[1]
//LI
//Можно так:

document.body.children[1].children[1]; // LI
///Может возникнуть проблема с комментарием в IE8-, так как он станет одним из children, в результате последний код станет работать некорректно.

//В последующих разделах учебника мы рассмотрим другие методы поиска по DOM, которые позволят эту проблему обойти.

////////////////////////////////////////////////////////////////

/*#185*/

//Вначале нерабочие способы, которые могут прийти на ум:

if (!elem) { .. }
//Это не работает, так как elem всегда есть, и является объектом. Так что проверка if (elem) всегда верна, вне зависимости от того, есть ли у elem потомки.

if (!elem.childNodes) { ... }
//Тоже не работает, так как псевдо-массив childNodes всегда существует. Он может быть пуст или непуст, но он всегда является объектом, так что проверка if (elem.childNodes) всегда верна.

//Несколько рабочих способов:

if (!elem.childNodes.length) { ... }

if (!elem.firstChild) { ... }

if (!elem.lastChild) { ... }
//Также существует метод hasChildNodes, который позволяет вызовом elem.hasChildNodes() определить наличие детей. Он работает так же, как проверка elem.childNodes.length != 0.

////////////////////////////////////////////////////////////////

/*#186*/

/*Да, верно, с оговоркой. Элемент elem.lastChild последний, у него нет правого соседа.

Оговорка: elem.lastChild.nextSibling выдаст ошибку если elem не имеет детей.

Нет, неверно, это может быть текстовый узел. Значением elem.children[0] является первый узел-элемент, перед ним может быть текст.

Аналогично предыдущему случаю, если у elem нет детей-элементов – будет ошибка.*/

////////////////////////////////////////////////////////////////

/*#187*/

/*Для удобства работы с таблицей используем специальные свойства rows и cells.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#188*/

Есть много вариантов решения, вот некоторые из них:

// 1
document.getElementById('age-table').getElementsByTagName('label');

// 2
document.getElementById('age-table').getElementsByTagName('td')[0];
// в современных браузерах можно одним запросом:
var result = document.querySelector('#age-table td');

// 3
document.getElementsByTagName('form')[1];

// 4
document.querySelector('form[name="search"]');

// 5
document.querySelector('form[name="search"] input')

// 6
document.getElementsByName("info[0]")[0];

// 7
document.querySelector('form[name="search-person"] [name="info[0]"]');

////////////////////////////////////////////////////////////////

/*#189*/

//Сделаем цикл по узлам <li>:

var lis = document.getElementsByTagName('li');

for (i = 0; i < lis.length; i++) {
  ...
}
/*В цикле для каждого lis[i] можно получить текст, используя свойство firstChild. Ведь первым в <li> является как раз текстовый узел, содержащий текст названия.

Также можно получить количество потомков, используя lis[i].getElementsByTagName('li').

Напишите код с этой подсказкой.

Если уж не выйдет – тогда откройте решение.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#190*/

//Ответ на первый вопрос
/*Ответ: 0, пустая коллекция.

 <ul id="menu">
  <li>Главная страница</li>
  <li>Форум</li>
  <li>Магазин</li>
</ul>
<script>*/
  var lis = document.body.getElementsByTagName('li');

  document.body.innerHTML = "";

  alert( lis.length );
/*</script>
Это потому, что все элементы из BODY удаляются, а коллекция – живая.

Ответ на второй вопрос
Ответ на второй вопрос зависит от браузера. В большинстве браузеров будет 3, коллекция не изменилась, так как она теперь привязана не к BODY, а к элементу, на котором идёт поиск, т.е. к menu.

Но элемент menu находится в переменной, и поэтому должен быть жив, а значит и его дети тоже. Но некоторые браузеры (IE10) используют агрессивный подход при работе с памятью и очищают все элементы, кроме тех, которые непосредственно хранятся в переменных.

Поэтому результат кода ниже в большинстве браузеров: 3, а в IE10: 0.

 <ul id="menu">
  <li>Главная страница</li>
  <li>Форум</li>
  <li>Магазин</li>
</ul>
<script>
  var menu = document.getElementById('menu');
  var lis = menu.getElementsByTagName('li');

  document.body.innerHTML = "";

  alert( lis.length );
</script>*/

////////////////////////////////////////////////////////////////

/*#191*/

/*Значение aList1 изменится, потому что getElementsByTagName – живая коллекция. Она автоматически дополнится новым элементом a и ее длина увеличится на 1.

А вот querySelector, наоборот, возвращает статичный список узлов. Он ссылается на те же самые элементы, что бы не происходило с документом. Поэтому длина aList2.length останется неизменной.*/

////////////////////////////////////////////////////////////////

/*#192*/

//Для бенчмаркинга будем использовать функцию bench(f, times), которая запускает функцию f times раз и возвращает разницу во времени:

function bench(f, times) {
  var d = new Date();
  for (var i = 0; i < times; i++) f();
  return new Date() - d;
}
//Первый вариант (неверный) – замерять разницу между функциями runGet/runQuery, вот так:

function runGet() {
  var results = document.getElementsByTagName('p');
}

function runQuery() {
  var results = document.querySelectorAll('p');
}

alert( bench(runGet, 10000) ); // вывести время 1000*runGet
/*Он даст неверные результаты, т.к. getElementsByTagName является «живым поисковым запросом». Если не обратиться к его результатам, то поиска не произойдет вообще, т.е. runGet ничего по сути не ищет.

…А querySelectorAll всегда производит поиск и формирует список элементов.

Более правильный тест – это не только запустить поиск, но и получить все элементы, как это делается в реальной жизни.*/

////////////////////////////////////////////////////////////////

/*#193*/

//Можно так:

var li = ul.getElementsByTagName('li')[1];
//Или так:

var li = ul.querySelector('li:nth-child(2)');
//Оба этих вызова будут перебирать детей UL и остановят перебор на найденном элементе.

//А вот так – браузер найдет все элементы, а затем выберет второй. Это дольше:

var li = ul.querySelectorAll('li')[1];
//На практике разница в производительности будет видна только для действительно больших списков, либо при частом выполнении запроса. Браузер перебирает элементы весьма шустро.

////////////////////////////////////////////////////////////////

/*#194*/

/*Небольшой подвох – в том, что во время выполнения скрипта последним тегом является SCRIPT. Браузер не может обработать страницу дальше, пока не выполнит скрипт.

Так что результат будет 1 (узел-элемент).

 <!DOCTYPE HTML>
<html>

<body>
  <script>
    alert( document.body.lastChild.nodeType );
  </script>
</body>

</html>*/

////////////////////////////////////////////////////////////////

/*#195*/

//Ответ: BODY.

  var body = document.body;

  body.innerHTML = "<!--" + body.tagName + "-->";

  alert( body.firstChild.data ); // BODY
/*Происходящее по шагам:

Заменяем содержимое <body> на комментарий. Он будет иметь вид <!–BODY–>, так как body.tagName == "BODY". Как мы помним, свойство tagName в HTML всегда находится в верхнем регистре.
Этот комментарий теперь является первым и единственным потомком body.firstChild.
Получим значение data для комментария body.firstChild. Оно равно содержимому узла для всех узлов, кроме элементов. Содержимое комментария: "BODY".*/

////////////////////////////////////////////////////////////////

/*#196*/

//Объектом какого класса является document, можно выяснить так:

 alert(document); // [object HTMLDocument]
//Или так:

 alert(document.constructor); // function HTMLDocument() { ... }
/*Итак, document – объект класса HTMLDocument.

Какое место HTMLDocument занимает в иерархии?

Можно поискать в документации. Но попробуем выяснить это самостоятельно.

Вопрос не такой простой и требует хорошего понимания прототипного наследования.*/

/*Вспомним, как оно устроено:

Методы объекта document находятся в prototype конструктора, в данном случае – HTMLDocument.prototype.
У HTMLDocument.prototype есть ссылка __proto__ на прототип-родитель.
У прототипа-родителя может быть ссылка __proto__ на его родитель, и так далее.
При поиске свойства в document, если его там нет, оно ищется в document.__proto__, затем в document.__proto__.__proto__ и так далее, пока не найдём, или пока цепочка __proto__ не закончится. Это обычное устройство класса, без наследования.

Нам нужно лишь узнать, что находится в этих самых __proto__.

Строго говоря, там могут быть любые объекты. Вовсе не обязательно, чтобы объектам из цепочки прототипов соответствовали какие-то конструкторы.

Вполне может быть цепочка, где родители – просто обычные JS-объекты:*/

document -> HTMLDocument.prototype -> obj1 -> obj2 -> ...
//Однако, здесь мы знаем, что наследование – «на классах», то есть, эти объекты obj1, obj2 являются prototype неких функций-конструкторов:

document -> HTMLDocument.prototype -> F1.prototype -> F2.prototype -> ...
/*Что стоит на месте F1, F2?

Опять же, если говорить про некие абстрактные объекты, то откуда нам знать, какие функции на них ссылаются через prototype? Ниоткуда. Один объект может быть в prototype хоть у десятка функций.

Но в стандартном прототипном наследовании один объект является prototype ровно у одной функции. Причём при создании функции в её prototype уже есть объект со свойством constructor, которое ссылается обратно на функцию:*/

F.prototype = { constructor: F }
//то свойство constructor, если конечно его не удалить или не перезаписать нечаянно (чего делать не следует), и позволяет из прототипа узнать соответствующий ему конструктор.

 // цепочка наследования:
alert(HTMLDocument.prototype.constructor); // function HTMLDocument
alert(HTMLDocument.prototype.__proto__.constructor); // function Document
alert(HTMLDocument.prototype.__proto__.__proto__.constructor); // function Node
/*При выводе объекта через console.dir(document) в Google Chrome, мы тоже можем, раскрывая __proto__, увидеть эти названия (HTMLDocument, Document, Node).

Браузерная консоль их берёт как раз из свойства constructor.

////////////////////////////////////////////////////////////////

/*#197*/

/*<body>

  <div id="widget" data-widget-name="menu">Выберите жанр</div>

  <script>
    var div = document.getElementById('widget');

    var widgetName = div.getAttribute('data-widget-name');
    // или так, кроме IE10-
    var widgetName = div.dataset.widgetName;

    alert( widgetName ); // "menu"
  </script>
</body>*/

////////////////////////////////////////////////////////////////

/*#198*/

/*Сначала можно найти ссылки, например, при помощи document.querySelectorAll('a'), а затем выбрать из них нужные.

Затем определимся – что использовать для проверки адреса ссылки: свойство href или атрибут getAttribute('href')?

Различие между ними заключается в том, что свойство будет содержать полный путь ссылки, а атрибут – значение, указанное в HTML.

Если открыть страницу локально, на диске, то для <a href="/tutorial"> значения будут такими:*/

a.getAttribute('href') == "/tutorial".
a.href == "file:///tutorial" (возможно, в пути будет также буква диска).
/*Здесь нужен именно атрибут, хотя бы потому, что в свойстве все ссылки уже с хостом и протоколом, а нам надо понять, был ли протокол в href или нет.

Правила определения:

Ссылки без href и без протокола :// являются заведомо внутренними.
Там, где протокол есть – проверяем, начинается ли адрес с http://internal.com.
Итого, код может быть таким:*/

var links = document.querySelectorAll('a');

for (var i = 0; i < links.length; i++) {

  var a = links[i];

  var href = a.getAttribute('href');

  if (!href) continue; // нет атрибута

  if (href.indexOf('://') == -1) continue; // без протокола

  if (href.indexOf('http://internal.com') === 0) continue; // внутренняя

  a.classList.add('external');
}
//…Но, как это часто бывает, знание CSS может упростить задачу. Удобнее и эффективнее здесь – указать проверки для href прямо в CSS-селекторе:

// ищем все ссылки, у которых в href есть протокол,
// но адрес начинается не с http://internal.com
var css = 'a[href*="://"]:not([href^="http://internal.com"])';
var links = document.querySelectorAll(css);

for (var i = 0; i < links.length; i++) {
  links[i].classList.add('external');
}

////////////////////////////////////////////////////////////////

/*#199*/

/*Результат выполнения может быть разный: innerHTML вставит именно HTML, а createTextNode интерпретирует теги как текст.

Запустите следующие примеры, чтобы увидеть разницу:

createTextNode создает текст „<b>текст</b>“:*/

/* <div id="elem"></div>
<script>
  var text = '<b>текст</b>';

  elem.appendChild(document.createTextNode(text));
</script>
innerHTML присваивает HTML <b>текст</b>:

 <div id="elem"></div>
<script>
  var text = '<b>текст</b>';

  elem.innerHTML = text;
</script>*/

////////////////////////////////////////////////////////////////

/*#200*/

/*Для того, чтобы добавить элемент после refElem, мы можем, используя insertBefore, вставить его перед refElem.nextSibling.

Но что если nextSibling нет? Это означает, что refElem является последним потомком своего родителя и можем использовать appendChild.

Код:*/

function insertAfter(elem, refElem) {
  var parent = refElem.parentNode;
  var next = refElem.nextSibling;
  if (next) {
    return parent.insertBefore(elem, next);
  } else {
    return parent.appendChild(elem);
  }
}
//Но код может быть гораздо короче, если вспомнить, что insertBefore со вторым аргументом null работает как appendChild:

function insertAfter(elem, refElem) {
  return refElem.parentNode.insertBefore(elem, refElem.nextSibling);
}
//Если нет nextSibling, то второй аргумент insertBefore становится null и тогда insertBefore(elem, null) осуществит вставку в конец, как и требуется.

//В решении нет проверки на существование refElem.parentNode, поскольку вставка после элемента без родителя – уже ошибка, пусть она возникнет в функции, это нормально.

////////////////////////////////////////////////////////////////

/*#201*/

/*Неправильное решение
Для начала рассмотрим забавный пример того, как делать не надо:*/

function removeChildren(elem) {
  for (var k = 0; k < elem.childNodes.length; k++) {
    elem.removeChild(elem.childNodes[k]);
  }
}
/*Если вы попробуете это на практике, то увидите, что это не сработает.

Не сработает потому, что коллекция childNodes всегда начинается с индекса 0 и автоматически обновляется, когда первый потомок удален(т.е. тот, что был вторым, станет первым). А переменная k в цикле всё время увеличивается, поэтому такой цикл пропустит половину узлов.

Решение через DOM
Правильное решение:*/

function removeChildren(elem) {
  while (elem.lastChild) {
    elem.removeChild(elem.lastChild);
  }
}
/*Альтернатива через innerHTML
Можно и просто обнулить содержимое через innerHTML:*/

function removeChildren(elem) {
  elem.innerHTML = '';
}
/*Это не будет работать в IE8- для таблиц, так как на большинстве табличных элементов (кроме ячеек TH/TD) в старых IE запрещено менять innerHTML.

Впрочем, можно завернуть innerHTML в try/catch:*/

function removeChildren(elem) {
  try {
    elem.innerHTML = '';
  } catch (e) {
    while (elem.firstChild) {
      elem.removeChild(elem.firstChild);
    }
  }
}

////////////////////////////////////////////////////////////////

/*#202*/

/*HTML в задаче некорректен. В этом всё дело. И вопрос легко решится, если открыть отладчик.

В нём видно, что браузер поместил текст aaa перед таблицей. Поэтому он и остался в документе.

Вообще, в стандарте HTML5 описано, как браузеру обрабатывать некорректный HTML, так что такое действие браузера является правильным.*/

////////////////////////////////////////////////////////////////

/*#203*/

/*Делаем цикл, пока посетитель что-то вводит – добавляет <li>.

Содержимое в <li> присваиваем через document.createTextNode, чтобы правильно работали <, > и т.д.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#204*/

/*Решения через рекурсию.
ссылки
Через innerHTML.
Через DOM.*/

////////////////////////////////////////////////////////////////

/*#205*/

/*Подсказки
Получить количество вложенных узлов можно через elem.getElementsByTagName('*').length.
Текст в начале <li> доступен как li.firstChild, его содержимое – li.firstChild.data.
Решение
Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#206*/

/*Для решения задачи сгенерируем таблицу в виде строки: "<table>...</table>", а затем присвоим в innerHTML.

Алгоритм:

Создать объект даты d = new Date(year, month-1). Это первый день месяца month (с учетом того, что месяцы в JS начинаются от 0, а не от 1).
Ячейки первого ряда пустые от начала и до дня недели d.getDay(), с которого начинается месяц. Создадим их.
Увеличиваем день в d на единицу: d.setDate(d.getDate()+1), и добавляем в календарь очередную ячейку, пока не достигли следующего месяца. При этом последний день недели означает вставку перевода строки «</tr><tr>».
При необходимости, если календарь окончился не на воскресенье – добавить пустые TD в таблицу, чтобы было все ровно.
Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#207*/

/*Для начала, придумаем подходящую HTML/CSS-структуру.

Здесь каждый компонент времени удобно поместить в соответствующий SPAN:

<div id="clock">
  <span class="hour">hh</span>:<span class="min">mm</span>:<span class="sec">ss</span>
</div>
Каждый SPAN раскрашивается при помощи CSS.

Жизнь часам будет обеспечивать функция update, вызываемая каждую секунду:*/

function update() {
  var clock = document.getElementById('clock');

  var date = new Date(); // (*)

  var hours = date.getHours();
  if (hours < 10) hours = '0' + hours;
  clock.children[0].innerHTML = hours;

  var minutes = date.getMinutes();
  if (minutes < 10) minutes = '0' + minutes;
  clock.children[1].innerHTML = minutes;

  var seconds = date.getSeconds();
  if (seconds < 10) seconds = '0' + seconds;
  clock.children[2].innerHTML = seconds;
}
/*В строке (*) каждый раз мы получаем текущую дату. Мы должны это сделать, несмотря на то, что, казалось бы, могли бы просто увеличивать счетчик каждую секунду.

На самом деле мы не можем опираться на счетчик для вычисления даты, т.к. setInterval не гарантирует точную задержку. Если в другом участке кода будет вызван alert, то часы остановятся, как и любые счетчики.

Функция clockStart для запуска часов:*/

var timerId;

function clockStart() { // запустить часы
  timerId = setInterval(update, 1000);
  update(); // (*)
}

function clockStop() {
  clearInterval(timerId);
  timerId = null;
}
//Обратите внимание, что вызов update не только запланирован, но и тут же производится в строке (*). Иначе посетителю пришлось бы ждать до первого выполнения setInterval, то есть целую секунду.

////////////////////////////////////////////////////////////////

/*#208*/

var ul = document.body.children[0];

ul.insertAdjacentHTML("beforeEnd", "<li>3</li><li>4</li><li>5</li>");

////////////////////////////////////////////////////////////////

/*#209*/

/*Для сортировки нам поможет функция sort массива.

Общая идея лежит на поверхности: сделать массив из строк и отсортировать его. Тонкости кроются в деталях.

В ифрейме ниже загружен документ, описывающий и реализующий разные алгоритмы. Обратите внимание: разница в производительности может достигать нескольких раз!

P.S. Создавать DocumentFragment здесь ни к чему. Можно вытащить из документа TBODY и иметь дело с ним в отрыве от DOM (алгоритм 4).

P.P.S. Если нужно сделать много узлов, то обычно innerHTML работает быстрее, чем удаление и вставка элементов через DOM-вызовы. То есть, сгенерировать таблицу заново эффективнее.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#210*/

/*Есть два варианта.

Можно использовать свойство elem.style.cssText и присвоить стиль в текстовом виде. При этом все присвоенные ранее свойства elem.style будут удалены.
Можно назначить подсвойства elem.style одно за другим. Этот способ более безопасен, т.к. меняет только явно присваемые свойства.
Мы выберем второй путь.

Описание CSS-свойств:

.button {
  -moz-border-radius: 8px;
  -webkit-border-radius: 8px;
  border-radius: 8px;
  border: 2px groove green;
  display: block;
  height: 30px;
  line-height: 30px;
  width: 100px;
  text-decoration: none;
  text-align: center;
  color: red;
  font-weight: bold;
}*/

////////////////////////////////////////////////////////////////

/*#211*/

//Открыть решение в песочнице.

////////////////////////////////////////////////////////////////

/*#212*/

elem.scrollHeight - elem.scrollTop - elem.clientHeight.

////////////////////////////////////////////////////////////////

/*#213*/

//Создадим элемент с прокруткой, но без border и padding. Тогда разница между его полной шириной offsetWidth и внутренней clientWidth будет равна как раз прокрутке:

 // создадим элемент с прокруткой
var div = document.createElement('div');

div.style.overflowY = 'scroll';
div.style.width = '50px';
div.style.height = '50px';

// при display:none размеры нельзя узнать
// нужно, чтобы элемент был видим,
// visibility:hidden - можно, т.к. сохраняет геометрию
div.style.visibility = 'hidden';

document.body.appendChild(div);
var scrollWidth = div.offsetWidth - div.clientWidth;
document.body.removeChild(div);

alert( scrollWidth );

////////////////////////////////////////////////////////////////

/*#214*/

/*Нам нужно создать div с такими же размерами и вставить его на место «переезжающего».

Один из вариантов – это просто клонировать элемент.

Если делать это при помощи div.cloneNode(true), то склонируется все содержимое, которого может быть много. Обычно нам это не нужно, поэтому можно использовать div.cloneNode(false) для клонирования элемента со стилями, и потом поправить его width/height.

Можно и просто создать новый div и поставить ему нужные размеры.

Всё, кроме margin, можно получить из свойств DOM-элемента, а margin – только через getComputedStyle.

Причём margin мы обязаны поставить, так как иначе наш элемент при вставке будет вести себя иначе, чем исходный.

Код:*/

var div = document.getElementById('moving-div');

var placeHolder = document.createElement('div');
placeHolder.style.height = div.offsetHeight + 'px';
// можно и width, но в этом примере это не обязательно
// из условия: Сделайте это путем создания вспомогательного DIV с теми же width...

// IE || другой браузер
var computedStyle = div.currentStyle || getComputedStyle(div, '');

placeHolder.style.marginTop = computedStyle.marginTop; // (1)
placeHolder.style.marginBottom = computedStyle.marginBottom;
//В строке (1) использование полного название свойства "marginTop" гарантирует, что полученное значение будет корректным.

////////////////////////////////////////////////////////////////

/*#215*/

/*При абсолютном позиционировании мяча внутри поля его координаты left/top отсчитываются от внутреннего угла поля, например верхнего-левого:


Метрики для внутренней зоны поля – это clientWidth/Height.

Центр – это (clientWidth/2, clientHeight/2).

Но если мы установим мячу такие значения ball.style.left/top, то в центре будет не сам мяч, а его левый верхний угол:*/

var ball = document.getElementById('ball');
var field = document.getElementById('field');

ball.style.left = Math.round(field.clientWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2) + 'px';

//Для того, чтобы центр мяча находился в центре поля, нам нужно сместить мяч на половину его ширины влево и на половину его высоты вверх.

var ball = document.getElementById('ball');
var field = document.getElementById('field');

ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';
/*Внимание, подводный камень!

Код выше стабильно работать не будет, потому что IMG идет без ширины/высоты:

<img src="ball.png" id="ball">
Высота и ширина изображения неизвестны браузеру до тех пор, пока оно не загрузится, если размер не указан явно.

После первой загрузки изображение уже будет в кеше браузера, и его размеры будут известны. Но когда браузер впервые видит документ – он ничего не знает о картинке, поэтому значение ball.offsetWidth равно 0. Вычислить координаты невозможно.

Чтобы это исправить, добавим width/height к картинке:

                                          <img src="ball.png" width="40" height="40" id="ball">
Теперь браузер всегда знает ширину и высоту, так что все работает. Тот же эффект дало бы указание размеров в CSS.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#216*/

/*Решение через width: auto
Вначале рассмотрим решение через «умную» установку CSS-свойства.

Они могут быть разными. Самое простое выглядит так:*/

elem.style.width = 'auto';
/*Такой способ работает, так как <div> по умолчанию распахивается на всю ширину.

Конечно, такое решение не будет работать для элементов, которые сами по себе не растягиваются, например в случае со <span> или при наличии position: absolute.

Обратим внимание, такой вариант был бы неверен:*/

elem.style.width = '100%';
/*По умолчанию в CSS ширина width – это то, что внутри padding, а проценты отсчитываются от ширины родителя. То есть, ставя ширину в 100%, мы говорим: «внутренняя область должна занимать 100% ширины родителя». А в элементе есть ещё padding, которые в итоге вылезут наружу.

Можно бы поменять блочную модель, указав box-sizing через свойство elem.style.boxSizing, но такое изменение потенциально может затронуть много других свойств, поэтому нежелательно.

Точное вычисление
Альтернатива – вычислить ширину родителя через clientWidth.

Доступную внутреннюю ширину родителя можно получить, вычитая из clientWidth размеры paddingLeft/paddingRight, и затем присвоить её элементу:*/

var bodyClientWidth = document.body.clientWidth;

var style = getComputedStyle(elem);

var bodyInnerWidth = bodyClientWidth - parseInt(style.paddingLeft) - parseInt(style.paddingRight);

elem.style.width = bodyInnerWidth + 'px';
/*Такое решение будет работать всегда, вне зависимости от типа элемента. Конечно, при изменении размеров окна браузера ширина не адаптируется к новому размеру автоматически, как с width:auto. Это недостаток. Его, конечно, тоже можно обойти при помощи событий (изучим далее), но как общий рецепт – если CSS может решить задачу – лучше использовать CSS.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#217*/

/*Отличия:

getComputedStyle не работает в IE8-.

clientWidth возвращает число, а getComputedStyle(...).width – строку, на конце px.

getComputedStyle не всегда даст ширину, он может вернуть, к примеру, "auto" для инлайнового элемента.

clientWidth соответствует внутренней видимой области элемента, *включая padding, а CSS-ширина width при стандартном значении box-sizing соответствует зоне внутри padding.

Если есть полоса прокрутки, то некоторые браузеры включают её ширину в width, а некоторые – нет.

Свойство clientWidth, с другой стороны, полностью кросс-браузерно. Оно всегда обозначает размер за вычетом прокрутки, т.е. реально доступный для содержимого.*/

////////////////////////////////////////////////////////////////

/*#218*/

/*Координаты внешних углов
Координаты элемента возвращаются функцией elem.getBoundingClientRect. Она возвращает все координаты относительно окна в виде объекта со свойствами left, top, right, bottom. Некоторые браузеры также добавляют width, height.

Так что координаты верхнего-левого coords1 и правого-нижнего coords2 внешних углов:*/

var coords = elem.getBoundingClientRect();

var coords1 = [coords.left, coords.top];
var coords2 = [coords.right, coords.bottom];
/*Левый-верхний угол внутри
Этот угол отстоит от наружных границ на размер рамки, который доступен через clientLeft/clientTop:*/

var coords3 = [coords.left + field.clientLeft, coords.top + field.clientTop];
/*Правый-нижний угол внутри
Этот угол отстоит от правой-нижней наружной границы на размер рамки. Так как нужная рамка находится справа-внизу, то специальных свойств для нее нет, но мы можем получить этот размер из CSS:
*/
var coords4 = [
  coords.right - parseInt(getComputedStyle(field).borderRightWidth),
  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)
]
/*Можно получить их альтернативным путем, прибавив clientWidth/clientHeight к координатам левого-верхнего внутреннего угла. Получится то же самое, пожалуй даже быстрее и изящнее.
*/
var coords4 = [
  coords.left + elem.clientLeft + elem.clientWidth,
  coords.top + elem.clientTop + elem.clientHeight
]

////////////////////////////////////////////////////////////////

/*#219*/

//Открыть решение в песочнице.

////////////////////////////////////////////////////////////////

/*#220*/

/*top – это pageYOffset.
bottom – это pageYOffset плюс высота видимой части documentElement.clientHeight.
height – полная высота документа, её вычисление дано в главе Размеры и прокрутка страницы.
Итого:*/

function getDocumentScroll() {
  var scrollHeight = Math.max(
    document.body.scrollHeight, document.documentElement.scrollHeight,
    document.body.offsetHeight, document.documentElement.offsetHeight,
    document.body.clientHeight, document.documentElement.clientHeight
  );

  return {
    top: pageYOffset,
    bottom: pageYOffset + document.documentElement.clientHeight,
    height: scrollHeight
  };
}

////////////////////////////////////////////////////////////////

/*#221*/

//Открыть решение в песочнице.

////////////////////////////////////////////////////////////////

/*#222*/

//Открыть решение в песочнице.

////////////////////////////////////////////////////////////////

/*#223*/

//Открыть решение в песочнице.

////////////////////////////////////////////////////////////////

/*#224*/

/*Решение задачи заключается в использовании this в обработчике.

 <input type="button" onclick="this.style.display='none'" value="Нажми, чтобы меня спрятать" />*/

////////////////////////////////////////////////////////////////

/*#225*/

/*Ответ: будет выведено 1 и 2.

Первый обработчик сработает, так как он не убран вызовом removeEventListener. Для удаления обработчика нужно передать в точности ту же функцию (ссылку на нее), что была назначена, а в коде передается такая же с виду функция, но, тем не менее, это другой объект.

Для того, чтобы удалить функцию-обработчик, нужно где-то сохранить ссылку на неё, например так:*/

function handler() {
  alert( "1" );
}

button.addEventListener("click", handler);
button.removeEventListener("click", handler);
//Обработчик button.onclick сработает независимо и в дополнение к назначенному в addEventListener.

////////////////////////////////////////////////////////////////

/*#226*/

/*Для начала, зададим структуру HTML/CSS.

Меню является отдельным графическим компонентом, его лучше поместить в единый DOM-элемент.

Элементы меню с точки зрения семантики являются списком UL/LI. Заголовок должен быть отдельным кликабельным элементом.

Получаем структуру:

<div class="menu">
  <span class="title">Сладости (нажми меня)!</span>
  <ul>
    <li>Пирог</li>
    <li>Пончик</li>
    <li>Мед</li>
  </ul>
</div>
Для заголовка лучше использовать именно SPAN, а не DIV, так как DIV постарается занять 100% ширины, и мы не сможем ловить click только на тексте:

<div style="border: solid red 1px">[Сладости (нажми меня)!]</div>

…А SPAN – это элемент с display: inline, поэтому он занимает ровно столько места, сколько занимает текст внутри него:

<span style="border: solid red 1px">[Сладости (нажми меня)!]</span>

Раскрытие/закрытие сделаем путём добавления/удаления класса .open к меню, который отвечает за стрелочку и отображение UL.

Обычно меню будет закрыто:

.menu ul {
  margin: 0;
  list-style: none;
  padding-left: 20px;
  display: none;
}

.menu .title::before {
  content: '▶ ';
  font-size: 80%;
  color: green;
}
Если же меню раскрыто, то есть имеет классы .menu и .open, то стрелочка слева заголовка меняется и список детей показывается:

.menu.open .title::before {
  content: '▼ ';
}

.menu.open ul {
  display: block;
}
Для JavaScript остался минимум работы – только добавить/удалить класс при клике.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#227*/

/*Изменим HTML/CSS, чтобы кнопка была в нужном месте сообщения. Кнопка – это тег <button>, поэтому понадобится несколько стилей.

Расположить кнопку справа можно при помощи position:relative для pane, а для кнопки position:absolute + right/top. Так как position:absolute вынимает элемент из потока, то кнопка может частично оказаться «сверху» текста заголовка, перекрыв его конец. Чтобы этого не произошло, можно добавить padding-right к заголовку.

Если использовать float:right, то кнопка никогда не перекроет текст. Это, пожалуй хорошо.

С другой стороны, потенциальным преимуществом способа с position по сравнению с float в данном случае является возможность поместить элемент кнопки в HTML после текста, а не до него.

Для того, чтобы получить кнопку из контейнера, используем querySelectorAll. На каждую кнопку повесим обработчик, который будет убирать родителя. Найти родителя можно через parentNode.*/

////////////////////////////////////////////////////////////////

/*#228*/

/*
Лента изображений в разметке должна быть представлена как список <ul> тегов <img>.

Нужно расположить его внутри <div> фиксированного размера, так чтобы в один момент была видна только нужная часть списка:


Чтобы список был длинный и элементы не переходили вниз, ему ставится width: 9999px, а элементам <li>, соответственно, float:left, либо для элементов используется display: inline-block, как в этом решении.

Главное – не использовать display:inline, так как такие элементы имеют дополнительные отступы снизу для возможных «хвостов букв».

В частности, для <img> нужно поставить в стилях явно display:block, чтобы пространства под ними не оставалось.

Для «прокрутки» будем сдвигать <ul>. Это можно делать по-разному, например, назначением CSS-свойства transform: translateX() или margin-left:


У внешнего <div> фиксированная ширина, поэтому «лишние» изображения обрезаются.

Снаружи окошка находятся стрелки и внешний контейнер.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#229*/

/*Мяч под курсор мыши
Основная сложность первого этапа – сдвинуть мяч под курсор, т.к. координаты клика e.clientX/Y – относительно окна, а мяч позиционирован абсолютно внутри поля, его координаты left/top нужно ставить относительно левого-верхнего внутреннего (внутри рамки!) угла поля.

Чтобы правильно вычислить координаты мяча, нужно получить координаты угла поля и вычесть их из clientX/Y:*/

var field = document.getElementById('field');
var ball = document.getElementById('ball');

field.onclick = function(e) {

  var fieldCoords = field.getBoundingClientRect();
  var fieldInnerCoords = {
    top: fieldCoords.top + field.clientTop,
    left: fieldCoords.left + field.clientLeft
  };

  ball.style.left = e.clientX - fieldInnerCoords.left + 'px';
  ball.style.top = e.clientY - fieldInnerCoords.top + 'px';

};
/*Далее мяч нужно сдвинуть на половину его ширины и высоты ball.clientWidth/clientHeight, чтобы он оказался центром под курсором.

Здесь есть важный «подводный камень» – размеры мяча в исходном документе не прописаны. Там просто стоит <img>. Но на момент выполнения JavaScript картинка, возможно, ещё не загрузилась, так что высота и ширина мяча будут неизвестны (а они необходимы для центрирования).

Нужно добавить width/height в тег <img> или задать размеры в CSS, тогда на момент выполнения JavaScript будет знать их и передвинет мяч правильно.

Код, который полностью центрирует мяч, вы найдете в полном решении:*/

////////////////////////////////////////////////////////////////

/*#230*/

/*Поставьте обработчик click на контейнере. Он должен проверять, произошел ли клик на кнопке удаления (target), и если да, то удалять соответствующий ей DIV.

Открыть решение в песочнице.*/

////////////////////////////////////////////////////////////////

/*#231*/

/*Схема решения
Дерево устроено как вложенный список.

Клики на все элементы можно поймать, повесив единый обработчик onclick на внешний UL.

Как поймать клик на заголовке? Элемент LI является блочным, поэтому нельзя понять, был ли клик на тексте, или справа от него.

Например, ниже – участок дерева с выделенными рамкой узлами. Кликните справа от любого заголовка. Видите, клик ловится? А лучше бы такие клики (не на тексте) игнорировать.

<style>
  li {
    border: 1px solid green;
  }
</style>

<ul onclick="alert(event.target)">
  <li>Млекопетающие
    <ul>
      <li>Коровы</li>
      <li>Ослы</li>
      <li>Собаки</li>
      <li>Тигры</li>
    </ul>
  </li>
</ul>*/

/*В примере выше видно, что проблема в верстке, в том что LI занимает всю ширину. Можно кликнуть справа от текста, это все еще LI.

Один из способов это поправить – обернуть заголовки в дополнительный элемент SPAN, и обрабатывать только клики внутри SPAN'ов, получать по SPAN'у его родителя LI и ставить ему класс открыт/закрыт.

Напишите для этого JavaScript-код.

Оборачиваем заголовки в SPAN
Следующий код ищет все LI и оборачивает текстовые узлы в SPAN.*/

var treeUl = document.getElementsByTagName('ul')[0];

var treeLis = treeUl.getElementsByTagName('li');

for (var i = 0; i < treeLis.length; i++) {
  var li = treeLis[i];

  var span = document.createElement('span');
  li.insertBefore(span, li.firstChild); // добавить пустой SPAN
  span.appendChild(span.nextSibling); // переместить в него заголовок
}
/*Теперь можно отслеживать клики на заголовках.

Так выглядит дерево с обёрнутыми в SPAN заголовками и делегированием:

<style>
  span {
    border: 1px solid red;
  }
</style>

<ul onclick="alert(event.target.tagName)">
  <li><span>Млекопетающие</span>
    <ul>
      <li><span>Коровы</span></li>
      <li><span>Ослы</span></li>
      <li><span>Собаки</span></li>
      <li><span>Тигры</span></li>
    </ul>
  </li>
</ul>*/

/*Так как SPAN – инлайновый элемент, он всегда такого же размера как текст. Да здравствует SPAN!

В реальной жизни дерево, скорее всего, будет сразу со SPAN: если HTML-код дерева генерируется на сервере, то это несложно, если дерево генерируется в JavaScript – тем более просто.

Итоговое решение
Для делегирования нужно по клику понять, на каком узле он произошел.

В нашем случае у SPAN нет детей-элементов, поэтому не нужно подниматься вверх по цепочке родителей. Достаточно просто проверить event.target.tagName == 'SPAN', чтобы понять, где был клик, и спрятать потомков.*/

var tree = document.getElementsByTagName('ul')[0];

tree.onclick = function(event) {
  var target = event.target;

  if (target.tagName != 'SPAN') {
    return; // клик был не на заголовке
  }

  var li = target.parentNode; // получить родительский LI

  // получить UL с потомками -- это первый UL внутри LI
  var childrenContainer = li.getElementsByTagName('ul')[0];

  if (!childrenContainer) return; // потомков нет -- ничего не надо делать

  // спрятать/показать (можно и через CSS-класс)
  childrenContainer.hidden = !childrenContainer.hidden;
}
//Выделение узлов жирным при наведении делается при помощи CSS-селектора :hover.

////////////////////////////////////////////////////////////////

/*#232*/

/*Подсказка (обработчик)
Обработчик onclick можно повесить один, на всю таблицу или THEAD. Он будет игнорировать клики не на TH.
При клике на TH обработчик будет получать номер из TH, на котором кликнули (TH.cellIndex) и вызывать функцию sortColumn, передавая ей номер колонки и тип.
Функция sortColumn(colNum, type) будет сортировать.
Подсказка (сортировка)
Функция сортировки:

Переносит все TR из TBODY в массив rowsArr
Сортирует массив, используя rowsArr.sort(compare), функция compare зависит от типа столбца.
Добавляет TR из массива обратно в TBODY*/

////////////////////////////////////////////////////////////////

/*#233*/

//Открыть решение в песочнице.

////////////////////////////////////////////////////////////////

/*#234*/

/*Дело в том, что обработчик из атрибута onclick делается браузером как функция с заданным телом.

То есть, в данном случае он будет таким:*/

function(event) {
  handler() // тело взято из атрибута onclick
}
/*При этом возвращаемое handler значение никак не используется и не влияет на результат.

Рабочий вариант:
 <script>
  function handler() {
    alert("...");
    return false;
  }
</script>

<a href="http://w3.org" onclick="return handler()">w3.org</a>
Также можно использовать объект события для вызова event.preventDefault(), например:
<script>
  function handler(event) {
    alert("...");
    event.preventDefault();
  }
</script>

<a href="http://w3.org" onclick="handler(event)">w3.org</a>*/

////////////////////////////////////////////////////////////////

/*#235*/

/*Это – классическая задача на тему делегирования.

В реальной жизни, мы можем перехватить событие и создать AJAX-запрос к серверу, который сохранит информацию о том, по какой ссылке ушел посетитель.

Мы перехватываем событие на contents и поднимаемся до parentNode пока не получим A или не упремся в контейнер.*/

contents.onclick = function(evt) {
  var target = evt.target;

  function handleLink(href) {
    var isLeaving = confirm('Уйти на ' + href + '?');
    if (!isLeaving) return false;
  }

  while (target != this) {
    if (target.nodeName == 'A') {
      return handleLink(target.getAttribute('href')); // (*)
    }
    target = target.parentNode;
  }
};
/*В строке (*) используется атрибут, а не свойство href, чтобы показать в confirm именно то, что написано в HTML-атрибуте, так как свойство может отличаться, оно обязано содержать полный валидный адрес.*/

////////////////////////////////////////////////////////////////

/*#236*/

/*Решение состоит в том, чтобы добавить обработчик на контейнер #thumbs и отслеживать клики на ссылках.

Когда происходит событие, обработчик должен изменять src #largeImg на href ссылки и заменять alt на ее title.

Код решения:*/

var largeImg = document.getElementById('largeImg');

document.getElementById('thumbs').onclick = function(e) {
  var target = e.target;

  while (target != this) {

    if (target.nodeName == 'A') {
      showThumbnail(target.href, target.title);
      return false;
    }

    target = target.parentNode;
  }

}

function showThumbnail(href, title) {
  largeImg.src = href;
  largeImg.alt = title;
}
/*Предзагрузка картинок

Для того, чтобы картинка загрузилась, достаточно создать новый элемент IMG и указать ему src, вот так:*/

var imgs = thumbs.getElementsByTagName('img');
for (var i = 0; i < imgs.length; i++) {
  var url = imgs[i].parentNode.href;

  var img = document.createElement('img');
  img.src = url;
}
/*Как только элемент создан и ему назначен src, браузер сам начинает скачивать файл картинки.

При правильных настройках сервера как-то использовать этот элемент не обязательно – картинка уже закеширована.

Семантичная верстка

Для списка картинок используется DIV. С точки зрения семантики более верный вариант – список UL/LI.*/