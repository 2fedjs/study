/*#1*/

/*Первым выполнится big.js, это нормальная последовательность выполнения подряд идущих скриптов.
Первым выполнится small.js, так как скрипты из-за async ведут себя совершенно независимо друг от друга, страница тоже от них не зависит.
Первым выполнится big.js, так как скрипты, подключённые через defer, сохраняют порядок выполнения относительно друг друга.*/

////////////////////////////////////////////////////////////////

/*#2*/

var a = 1, b = 1, c, d;

// префиксная форма сначала увеличивает a до 2, а потом возвращает
c = ++a; alert(c); // 2

// постфиксная форма увеличивает, но возвращает старое значение
d = b++; alert(d); // 1

// сначала увеличили a до 3, потом использовали в арифметике
c = (2+ ++a); alert(c); // 5

// увеличили b до 3, но в этом выражении оставили старое значение
d = (2+ b++); alert(d); // 4

// каждую переменную увеличили по 2 раза
alert(a); // 3
alert(b); // 3

////////////////////////////////////////////////////////////////

/*#3*/

//Ответ: x = 5.

//Оператор присваивания возвращает значение, которое будет записано в переменную, например:

 var a = 2;
alert( a *= 2 ); // 4
//Отсюда x = 1 + 4 = 5.

////////////////////////////////////////////////////////////////

/*#4*/

/*1. Операция a^b ставит бит результата в 1, если на соответствующей битовой позиции в a или b (но не одновременно) стоит 1.

Так как в 0 везде стоят нули, то биты берутся в точности как во втором аргументе.

2. Первое побитовое НЕ ~ превращает 0 в 1, а 1 в 0. А второе НЕ превращает ещё раз, в итоге получается как было.*/

////////////////////////////////////////////////////////////////

/*#5*/

//Один из вариантов такой функции:

 function isInteger(num) {
  return (num ^ 0) === num;
}

alert( isInteger(1) ); // true
alert( isInteger(1.5) ); // false
alert( isInteger(-0.5) ); // false
//Обратите внимание: num^0 – в скобках! Это потому, что приоритет операции ^ очень низкий. Если не поставить скобку, то === сработает раньше. Получится num ^ (0 === num), а это уже совсем другое дело.

////////////////////////////////////////////////////////////////

/*#6*/

/*Операция над числами, в конечном итоге, сводится к битам.

Посмотрим, можно ли поменять местами биты слева и справа.

Например, таблица истинности для ^:

a	b	результат
0	0	0
0	1	1
1	0	1
1	1	0
Случаи 0^0 и 1^1 заведомо не изменятся при перемене мест, поэтому нас не интересуют. А вот 0^1 и 1^0 эквивалентны и равны 1.

Аналогично можно увидеть, что и другие операторы симметричны.

Ответ: да.*/

////////////////////////////////////////////////////////////////

/*#7*/

/*Всё дело в том, что побитовые операции преобразуют число в 32-битное целое.

Обычно число в JavaScript имеет 64-битный формат с плавающей точкой. При этом часть битов (52) отведены под цифры, часть (11) отведены под хранение номера позиции, на которой стоит десятичная точка, и один бит – знак числа.

Это означает, что максимальное целое число, которое можно хранить, занимает 52 бита.

Число 12345678912345 в двоичном виде: 10110011101001110011110011100101101101011001 (44 цифры).

Побитовый оператор ^ преобразует его в 32-битное путём отбрасывания десятичной точки и «лишних» старших цифр. При этом, так как число большое и старшие биты здесь ненулевые, то, естественно, оно изменится.

Вот ещё пример:*/

 // в двоичном виде 1000000000000000000000000000000 (31 цифры)
alert( Math.pow(2, 30) ); // 1073741824
alert( Math.pow(2, 30) ^ 0 ); // 1073741824, всё ок, длины хватает

// в двоичном виде 100000000000000000000000000000000 (33 цифры)
alert( Math.pow(2, 32) ); // 4294967296
alert( Math.pow(2, 32) ^ 0 ); // 0, отброшены старшие цифры, остались нули

// пограничный случай
// в двоичном виде 10000000000000000000000000000000 (32 цифры)
alert( Math.pow(2, 31) ); // 2147483648
alert( Math.pow(2, 31) ^ 0 ); // -2147483648, ничего не отброшено,
// но первый бит 1 теперь стоит в начале числа и является знаковым

////////////////////////////////////////////////////////////////

/*#8*/

/*Да, выведется, т.к. внутри if стоит строка "0".

Любая строка, кроме пустой (а здесь она не пустая), в логическом контексте является true.

Можно запустить и проверить:
*/
 if ("0") {
  alert( 'Привет' );
}

////////////////////////////////////////////////////////////////

/*#9*/

var value = prompt('Введите число', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}

////////////////////////////////////////////////////////////////

/*#10*/

result = (a + b < 4) ? 'Мало' : 'Много';

////////////////////////////////////////////////////////////////

/*#11*/

var message = (login == 'Вася') ? 'Привет' :
  (login == 'Директор') ? 'Здравствуйте' :
  (login == '') ? 'Нет логина' :
  '';

////////////////////////////////////////////////////////////////

/*#12*/

//Ответ: 2, это первое значение, которое в логическом контексте даст true.

 alert( null || 2 || undefined );

////////////////////////////////////////////////////////////////

/*#13*/

//Ответ: сначала 1, затем 2.

 alert( alert(1) || 2 || alert(3) );
//Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

//Первый оператор ИЛИ || выполнит первый alert(1), получит undefined и пойдёт дальше, ко второму операнду.
//Так как второй операнд 2 является истинным, то вычисления завершатся, результатом undefined || 2 будет 2, которое будет выведено внешним alert( .... ).
//Второй оператор || не будет выполнен, выполнение до alert(3) не дойдёт, поэтому 3 выведено не будет.

////////////////////////////////////////////////////////////////

/*#14*/

//Ответ: null, это первое ложное значение из списка.

 alert( 1 && null && 2 );

////////////////////////////////////////////////////////////////

/*#15*/

//Ответ: 1, а затем undefined.

 alert( alert(1) && alert(2) );
//Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

//Поэтому до правого alert дело не дойдёт, вычисления закончатся на левом.

////////////////////////////////////////////////////////////////

/*#16*/

//Ответ: 3.

 alert( null || 2 && 3 || 4 );
//Приоритет оператора && выше, чем ||, поэтому он выполнится первым.

//Последовательность вычислений:

null || 2 && 3 || 4
null || 3 || 4
3

////////////////////////////////////////////////////////////////

/*#17*/

if (age >= 14 && age <= 90)

////////////////////////////////////////////////////////////////

/*#18*/

//Первый вариант:

if (!(age >= 14 && age <= 90))
//Второй вариант:

if (age < 14 || age > 90)

////////////////////////////////////////////////////////////////

/*#19*/

/*Ответ: первое и третье выполнятся.

Детали:*/

 // Выполнится
// Результат -1 || 0 = -1, в логическом контексте true
if (-1 || 0) alert( 'первое' );

// Не выполнится
// -1 && 0 = 0,  в логическом контексте false
if (-1 && 0) alert( 'второе' );

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1 -> null || 1 -> 1
if (null || -1 && 1) alert( 'третье' );

////////////////////////////////////////////////////////////////

/*#20*/

"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5
 = "$45"
"4" - 2
 = 2
"4px" - 2
 = NaN
7 / 0
 = Infinity
" -9\n" + 5 = " -9\n5"
" -9\n" - 5 = -14
5 && 2
 = 2
2 && 5
 = 5
5 || 0
 = 5
0 || 5 = 5
null + 1 = 1 // (3)
undefined + 1 = NaN // (4)
null == "\n0\n" = false // (5)
+null == +"\n0\n" = true // (6)
/*1. Оператор "+" в данном случае прибавляет 1 как строку, и затем 0.
2. Оператор "-" работает только с числами, так что он сразу приводит "" к 0.
3. null при численном преобразовании становится 0
4. undefined при численном преобразовании становится NaN
5. При сравнении == с null преобразования не происходит, есть жёсткое правило: null == undefined и только.
6. И левая и правая часть == преобразуются к числу 0.*/

////////////////////////////////////////////////////////////////

/*#21*/

//Ответ: 1.

 var i = 3;

while (i) {
  alert( i-- );
}
/*Каждое выполнение цикла уменьшает i. Проверка while(i) даст сигнал «стоп» при i = 0.

Соответственно, шаги цикла:
*/
var i = 3
alert( i-- ); // выведет 3, затем уменьшит i до 2

alert(i--) // выведет 2, затем уменьшит i до 1

alert(i--) // выведет 1, затем уменьшит i до 0

// все, проверка while(i) не даст выполняться циклу дальше

////////////////////////////////////////////////////////////////

/*#22*/

//От 1 до 4

 var i = 0;
while (++i < 5) alert( i );
//Первое значение: i=1, так как операция ++i сначала увеличит i, а потом уже произойдёт сравнение и выполнение alert.

//Далее 2,3,4.. Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как ++ стоит перед переменной.

//При i=4 произойдет увеличение i до 5, а потом сравнение while(5 < 5) – это неверно. Поэтому на этом цикл остановится, и значение 5 выведено не будет.

//От 1 до 5

 var i = 0;
while (i++ < 5) alert( i );
//Первое значение: i=1. Остановимся на нём подробнее. Оператор i++ увеличивает i, возвращая старое значение, так что в сравнении i++ < 5 будет участвовать старое i=0.

//Но последующий вызов alert уже не относится к этому выражению, так что получит новый i=1.

//Далее 2,3,4.. Для каждого значения сначала происходит сравнение, а потом – увеличение, и затем срабатывание alert.

//Окончание цикла: при i=4 произойдет сравнение while(4 < 5) – верно, после этого сработает i++, увеличив i до 5, так что значение 5 будет выведено. Оно станет последним.

////////////////////////////////////////////////////////////////

/*#23*/

//Ответ: от 0 до 4 в обоих случаях.

 for (var i = 0; i < 5; ++i) alert( i );

for (var i = 0; i < 5; i++) alert( i );
//Такой результат обусловлен алгоритмом работы for:

/*Выполнить присвоение i=0
Проверить i<5
Если верно – выполнить тело цикла alert(i), затем выполнить i++
Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.*/

////////////////////////////////////////////////////////////////

/*#24*/

for (var i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
//Чётность проверяется по остатку при делении на 2, используя оператор «деление с остатком» %: i % 2.

////////////////////////////////////////////////////////////////

/*#25*/

var i = 0;
while (i < 3) {
  alert( "номер " + i + "!" );
  i++;
}

////////////////////////////////////////////////////////////////

/*#26*/

var num;

do {
  num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num != null);
/*Цикл do..while повторяется, пока верны две проверки:

Проверка num <= 100 – то есть, введённое число всё еще меньше 100.
Проверка num != null – значение null означает, что посетитель нажал «Отмена», в этом случае цикл тоже нужно прекратить.
Кстати, сравнение num <= 100 при вводе null даст true, так что вторая проверка необходима.*/

////////////////////////////////////////////////////////////////

/*#27*/

/*Схема решения
Для всех i от 1 до 10 {
  проверить, делится ли число i на какое - либо из чисел до него
  если делится, то это i не подходит, берем следующее
  если не делится, то i - простое число
}
Решение
Решение с использованием метки:*/

 nextPrime:
  for (var i = 2; i <= 10; i++) {

    for (var j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
//Конечно же, его можно оптимизировать с точки зрения производительности. Например, проверять все j не от 2 до i, а от 2 до квадратного корня из i. А для очень больших чисел – существуют более эффективные специализированные алгоритмы проверки простоты числа, например квадратичное решето и решето числового поля.

////////////////////////////////////////////////////////////////

/*#28*/

/*Один или ноль
Два*/

////////////////////////////////////////////////////////////////

/*#29*/

//Если совсем точно следовать условию, то сравнение должно быть строгим '==='.

//В реальном случае, скорее всего, подойдёт обычное сравнение '=='.

if(browser == 'IE') {
  alert('О, да у вас IE!');
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert('Да, и эти браузеры мы поддерживаем');
} else {
  alert('Мы надеемся, что и в вашем браузере все ок!');
}
//Обратите внимание: конструкция browser == 'Chrome' || browser == 'Firefox' ... разбита на несколько строк для лучшей читаемости.

//Но всё равно запись через switch нагляднее.

////////////////////////////////////////////////////////////////

/*#30*/

//Первые две проверки – обычный case, третья разделена на два case:

var a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
//Обратите внимание: break внизу не обязателен, но ставится по «правилам хорошего тона».

//Допустим, он не стоит. Есть шанс, что в будущем нам понадобится добавить в конец ещё один case, например case 4, и мы, вполне вероятно, забудем этот break поставить. В результате выполнение case 2/case 3 продолжится на case 4 и будет ошибка.

////////////////////////////////////////////////////////////////

/*#31*/

//Оба варианта функции работают одинаково, отличий нет.

////////////////////////////////////////////////////////////////

/*#32*/

//Используя оператор '?':

function checkAge(age) {
  return (age > 18) ? true : confirm('Родители разрешили?');
}
//Используя оператор || (самый короткий вариант):

function checkAge(age) {
  return (age > 18) || confirm('Родители разрешили?');
}

////////////////////////////////////////////////////////////////

/*#33*/

//Вариант решения с использованием if:

function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
//Вариант решения с оператором '?':

function min(a, b) {
  return a < b ? a : b;
}
//P.S. Случай равенства a == b здесь отдельно не рассматривается, так как при этом неважно, что возвращать.

////////////////////////////////////////////////////////////////

/*#34*/

/**
 * Возводит x в степень n (комментарий JSDoc)
 *
 * @param {number} x число, которое возводится в степень
 * @param {number} n степень, должна быть целым числом больше 1
 *
 * @return {number} x в степени n
 */
function pow(x, n) {
  var result = x;

  for (var i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

var x = prompt("x?", '');
var n = prompt("n?", '');

if (n <= 1) {
  alert('Степень ' + n +
    'не поддерживается, введите целую степень, большую 1'
  );
} else {
  alert( pow(x, n) );
}

////////////////////////////////////////////////////////////////

/*#35*/

//Решение с использованием цикла:

 function sumTo(n) {
  var sum = 0;
  for (var i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
//Решение через рекурсию:

 function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
//Решение по формуле: sumTo(n) = n*(n+1)/2:

 function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
//P.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.

//Вариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов.

//Рекурсия в данном случае работает медленнее всех.

//P.P.S. Существует ограничение глубины вложенных вызовов, поэтому рекурсивный вызов sumTo(100000) выдаст ошибку.

////////////////////////////////////////////////////////////////

/*#36*/

//По свойствам факториала, как описано в условии, n! можно записать как n * (n-1)!.

//То есть, результат функции для n можно получить как n, умноженное на результат функции для n-1, и так далее до 1!:

 function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
//Базисом рекурсии является значение 1. А можно было бы сделать базисом и 0. Тогда код станет чуть короче:

 function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
//В этом случае вызов factorial(1) сведётся к 1*factorial(0), будет дополнительный шаг рекурсии.

////////////////////////////////////////////////////////////////

/*#37*/

/*Вычисление рекурсией (медленное)
Решение по формуле, используя рекурсию:*/

 function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // не запускаем, подвесит браузер
/*При больших значениях n оно будет работать очень медленно. Например, fib(77) уже будет вычисляться очень долго.

Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз. Например, посмотрим на отрывок вычислений:

...*/
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
//...
/*Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено два раза, совершенно независимо.

Можно это оптимизировать, запоминая уже вычисленные значения, получится гораздо быстрее. Альтернативный вариант – вообще отказаться от рекурсии, а вместо этого в цикле начать с первых значений 1, 2, затем из них получить fib(3), далее fib(4), затем fib(5) и так далее, до нужного значения.

Это решение будет наиболее эффективным. Попробуйте его написать.

Алгоритм вычисления в цикле
Будем идти по формуле слева-направо:
*/
var a = 1, b = 1; // начальные значения
var c = a + b; // 2

/* переменные на начальном шаге:
a  b  c
1, 1, 2
*/
//Теперь следующий шаг, присвоим a и b текущие 2 числа и получим новое следующее в c:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
   a  b  c
1, 1, 2, 3
*/
//Следующий шаг даст нам ещё одно число последовательности:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
      a  b  c
1, 1, 2, 3, 5
*/
//Повторять в цикле до тех пор, пока не получим нужное значение. Это гораздо быстрее, чем рекурсия, хотя бы потому что ни одно из чисел не вычисляется дважды.

//P.S. Этот подход к вычислению называется динамическое программирование снизу-вверх.

//Код для вычисления в цикле
 function fib(n) {
  var a = 1,
    b = 1;
  for (var i = 3; i <= n; i++) {
    var c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
//Цикл здесь начинается с i=3, так как первое и второе числа Фибоначчи заранее записаны в переменные a=1, b=1.

////////////////////////////////////////////////////////////////

/*#38*/

//Первый код выведет function ..., второй – ошибку во всех браузерах, кроме IE8-.

 // обычное объявление функции (Function Declaration)
function g() { return 1; };

alert(g); // функция
//Во втором коде скобки есть, значит функция внутри является не Function Declaration, а частью выражения, то есть Named Function Expression. Его имя видно только внутри, снаружи переменная g не определена.

 // Named Function Expression!
(function g() { return 1; });

alert(g);  // Ошибка!
//Все браузеры, кроме IE8-, поддерживают это ограничение видимости и выведут ошибку, "undefined variable".

////////////////////////////////////////////////////////////////

/*#39*/

function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  var result = 1;
  for (var i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}

////////////////////////////////////////////////////////////////

/*#40*/

//Новый тест может быть, к примеру, таким:

it("любое число в степени 0 равно 1", function() {
  assert.equal(pow(123, 0), 1);
});
/*Конечно, желательно проверить на нескольких числах.

Поэтому лучше будет создать блок describe, аналогичный тому, что мы делали для произвольных чисел:*/

describe("любое число, кроме нуля, в степени 0 равно 1", function() {

  function makeTest(x) {
    it("при возведении " + x + " в степень 0 результат: 1", function() {
      assert.equal(pow(x, 0), 1);
    });
  }

  for (var x = -5; x <= 5; x += 2) {
    makeTest(x);
  }

});
/*И не забудем добавить отдельный тест для нуля:

...*/
it("ноль в нулевой степени даёт NaN", function() {
  assert( isNaN(pow(0, 0)), "0 в степени 0 не NaN");
});
//...

////////////////////////////////////////////////////////////////

/*#41*/

/*Этот тест демонстрирует один из соблазнов, которые ожидают начинающего автора тестов.

Вместо того, чтобы написать три различных теста, он изложил их в виде одного потока вычислений, с несколькими assert.

Иногда так написать легче и проще, однако при ошибке в тесте гораздо менее очевидно, что же пошло не так.

Если в сложном тесте произошла ошибка где-то посередине потока вычислений, то придётся выяснять, какие конкретно были входные и выходные данные на этот момент, то есть по сути – отлаживать код самого теста.

Гораздо лучше будет разбить тест на несколько блоков it, с чётко прописанными входными и выходными данными.*/

describe("Возводит x в степень n", function() {
  it("5 в степени 1 равно 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 в степени 2 равно 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 в степени 3 равно 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
//Можно использовать цикл для генерации блоков it, в этом случае важно, чтобы сам код такого цикла был достаточно простым. Иногда проще записать несколько блоков it вручную, как сделано выше, чем «городить огород» из синтаксических конструкций.