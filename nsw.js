#1*/

/*Первым выполнится big.js, это нормальная последовательность выполнения подряд идущих скриптов.
Первым выполнится small.js, так как скрипты из-за async ведут себя совершенно независимо друг от друга, страница тоже от них не зависит.
Первым выполнится big.js, так как скрипты, подключённые через defer, сохраняют порядок выполнения относительно друг друга.*/

////////////////////////////////////////////////////////////////

/*#2*/

var a = 1, b = 1, c, d;

// префиксная форма сначала увеличивает a до 2, а потом возвращает
c = ++a; alert(c); // 2

// постфиксная форма увеличивает, но возвращает старое значение
d = b++; alert(d); // 1

// сначала увеличили a до 3, потом использовали в арифметике
c = (2+ ++a); alert(c); // 5

// увеличили b до 3, но в этом выражении оставили старое значение
d = (2+ b++); alert(d); // 4

// каждую переменную увеличили по 2 раза
alert(a); // 3
alert(b); // 3

////////////////////////////////////////////////////////////////

/*#3*/

//Ответ: x = 5.

//Оператор присваивания возвращает значение, которое будет записано в переменную, например:

 var a = 2;
alert( a *= 2 ); // 4
//Отсюда x = 1 + 4 = 5.

////////////////////////////////////////////////////////////////

/*#4*/

/*1. Операция a^b ставит бит результата в 1, если на соответствующей битовой позиции в a или b (но не одновременно) стоит 1.

Так как в 0 везде стоят нули, то биты берутся в точности как во втором аргументе.

2. Первое побитовое НЕ ~ превращает 0 в 1, а 1 в 0. А второе НЕ превращает ещё раз, в итоге получается как было.*/

////////////////////////////////////////////////////////////////

/*#5*/

//Один из вариантов такой функции:

 function isInteger(num) {
  return (num ^ 0) === num;
}

alert( isInteger(1) ); // true
alert( isInteger(1.5) ); // false
alert( isInteger(-0.5) ); // false
//Обратите внимание: num^0 – в скобках! Это потому, что приоритет операции ^ очень низкий. Если не поставить скобку, то === сработает раньше. Получится num ^ (0 === num), а это уже совсем другое дело.

////////////////////////////////////////////////////////////////

/*#6*/

/*Операция над числами, в конечном итоге, сводится к битам.

Посмотрим, можно ли поменять местами биты слева и справа.

Например, таблица истинности для ^:

a	b	результат
0	0	0
0	1	1
1	0	1
1	1	0
Случаи 0^0 и 1^1 заведомо не изменятся при перемене мест, поэтому нас не интересуют. А вот 0^1 и 1^0 эквивалентны и равны 1.

Аналогично можно увидеть, что и другие операторы симметричны.

Ответ: да.*/

////////////////////////////////////////////////////////////////

/*#7*/

/*Всё дело в том, что побитовые операции преобразуют число в 32-битное целое.

Обычно число в JavaScript имеет 64-битный формат с плавающей точкой. При этом часть битов (52) отведены под цифры, часть (11) отведены под хранение номера позиции, на которой стоит десятичная точка, и один бит – знак числа.

Это означает, что максимальное целое число, которое можно хранить, занимает 52 бита.

Число 12345678912345 в двоичном виде: 10110011101001110011110011100101101101011001 (44 цифры).

Побитовый оператор ^ преобразует его в 32-битное путём отбрасывания десятичной точки и «лишних» старших цифр. При этом, так как число большое и старшие биты здесь ненулевые, то, естественно, оно изменится.

Вот ещё пример:*/

 // в двоичном виде 1000000000000000000000000000000 (31 цифры)
alert( Math.pow(2, 30) ); // 1073741824
alert( Math.pow(2, 30) ^ 0 ); // 1073741824, всё ок, длины хватает

// в двоичном виде 100000000000000000000000000000000 (33 цифры)
alert( Math.pow(2, 32) ); // 4294967296
alert( Math.pow(2, 32) ^ 0 ); // 0, отброшены старшие цифры, остались нули

// пограничный случай
// в двоичном виде 10000000000000000000000000000000 (32 цифры)
alert( Math.pow(2, 31) ); // 2147483648
alert( Math.pow(2, 31) ^ 0 ); // -2147483648, ничего не отброшено,
// но первый бит 1 теперь стоит в начале числа и является знаковым

////////////////////////////////////////////////////////////////

/*#8*/

/*Да, выведется, т.к. внутри if стоит строка "0".

Любая строка, кроме пустой (а здесь она не пустая), в логическом контексте является true.

Можно запустить и проверить:
*/
 if ("0") {
  alert( 'Привет' );
}

////////////////////////////////////////////////////////////////

/*#9*/

var value = prompt('Введите число', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}

////////////////////////////////////////////////////////////////

/*#10*/

result = (a + b < 4) ? 'Мало' : 'Много';

////////////////////////////////////////////////////////////////

/*#11*/

var message = (login == 'Вася') ? 'Привет' :
  (login == 'Директор') ? 'Здравствуйте' :
  (login == '') ? 'Нет логина' :
  '';

////////////////////////////////////////////////////////////////

/*#12*/

//Ответ: 2, это первое значение, которое в логическом контексте даст true.

 alert( null || 2 || undefined );

////////////////////////////////////////////////////////////////

/*#13*/

//Ответ: сначала 1, затем 2.

 alert( alert(1) || 2 || alert(3) );
//Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

//Первый оператор ИЛИ || выполнит первый alert(1), получит undefined и пойдёт дальше, ко второму операнду.
//Так как второй операнд 2 является истинным, то вычисления завершатся, результатом undefined || 2 будет 2, которое будет выведено внешним alert( .... ).
//Второй оператор || не будет выполнен, выполнение до alert(3) не дойдёт, поэтому 3 выведено не будет.

////////////////////////////////////////////////////////////////

/*#14*/

//Ответ: null, это первое ложное значение из списка.

 alert( 1 && null && 2 );

////////////////////////////////////////////////////////////////

/*#15*/

//Ответ: 1, а затем undefined.

 alert( alert(1) && alert(2) );
//Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

//Поэтому до правого alert дело не дойдёт, вычисления закончатся на левом.

////////////////////////////////////////////////////////////////

/*#16*/

//Ответ: 3.

 alert( null || 2 && 3 || 4 );
//Приоритет оператора && выше, чем ||, поэтому он выполнится первым.

//Последовательность вычислений:

null || 2 && 3 || 4
null || 3 || 4
3

////////////////////////////////////////////////////////////////

/*#17*/

if (age >= 14 && age <= 90)

////////////////////////////////////////////////////////////////

/*#18*/

//Первый вариант:

if (!(age >= 14 && age <= 90))
//Второй вариант:

if (age < 14 || age > 90)

////////////////////////////////////////////////////////////////

/*#19*/

/*Ответ: первое и третье выполнятся.

Детали:*/

 // Выполнится
// Результат -1 || 0 = -1, в логическом контексте true
if (-1 || 0) alert( 'первое' );

// Не выполнится
// -1 && 0 = 0,  в логическом контексте false
if (-1 && 0) alert( 'второе' );

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1 -> null || 1 -> 1
if (null || -1 && 1) alert( 'третье' );

////////////////////////////////////////////////////////////////

/*#20*/

"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5
 = "$45"
"4" - 2
 = 2
"4px" - 2
 = NaN
7 / 0
 = Infinity
" -9\n" + 5 = " -9\n5"
" -9\n" - 5 = -14
5 && 2
 = 2
2 && 5
 = 5
5 || 0
 = 5
0 || 5 = 5
null + 1 = 1 // (3)
undefined + 1 = NaN // (4)
null == "\n0\n" = false // (5)
+null == +"\n0\n" = true // (6)
/*1. Оператор "+" в данном случае прибавляет 1 как строку, и затем 0.
2. Оператор "-" работает только с числами, так что он сразу приводит "" к 0.
3. null при численном преобразовании становится 0
4. undefined при численном преобразовании становится NaN
5. При сравнении == с null преобразования не происходит, есть жёсткое правило: null == undefined и только.
6. И левая и правая часть == преобразуются к числу 0.*/

////////////////////////////////////////////////////////////////

/*#21*/

//Ответ: 1.

 var i = 3;

while (i) {
  alert( i-- );
}
/*Каждое выполнение цикла уменьшает i. Проверка while(i) даст сигнал «стоп» при i = 0.

Соответственно, шаги цикла:
*/
var i = 3
alert( i-- ); // выведет 3, затем уменьшит i до 2

alert(i--) // выведет 2, затем уменьшит i до 1

alert(i--) // выведет 1, затем уменьшит i до 0

// все, проверка while(i) не даст выполняться циклу дальше

////////////////////////////////////////////////////////////////

/*#22*/

//От 1 до 4

 var i = 0;
while (++i < 5) alert( i );
//Первое значение: i=1, так как операция ++i сначала увеличит i, а потом уже произойдёт сравнение и выполнение alert.

//Далее 2,3,4.. Значения выводятся одно за другим. Для каждого значения сначала происходит увеличение, а потом – сравнение, так как ++ стоит перед переменной.

//При i=4 произойдет увеличение i до 5, а потом сравнение while(5 < 5) – это неверно. Поэтому на этом цикл остановится, и значение 5 выведено не будет.

//От 1 до 5

 var i = 0;
while (i++ < 5) alert( i );
//Первое значение: i=1. Остановимся на нём подробнее. Оператор i++ увеличивает i, возвращая старое значение, так что в сравнении i++ < 5 будет участвовать старое i=0.

//Но последующий вызов alert уже не относится к этому выражению, так что получит новый i=1.

//Далее 2,3,4.. Для каждого значения сначала происходит сравнение, а потом – увеличение, и затем срабатывание alert.

//Окончание цикла: при i=4 произойдет сравнение while(4 < 5) – верно, после этого сработает i++, увеличив i до 5, так что значение 5 будет выведено. Оно станет последним.

////////////////////////////////////////////////////////////////

/*#23*/

//Ответ: от 0 до 4 в обоих случаях.

 for (var i = 0; i < 5; ++i) alert( i );

for (var i = 0; i < 5; i++) alert( i );
//Такой результат обусловлен алгоритмом работы for:

/*Выполнить присвоение i=0
Проверить i<5
Если верно – выполнить тело цикла alert(i), затем выполнить i++
Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.*/

////////////////////////////////////////////////////////////////

/*#24*/

for (var i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
//Чётность проверяется по остатку при делении на 2, используя оператор «деление с остатком» %: i % 2.

////////////////////////////////////////////////////////////////

/*#25*/

var i = 0;
while (i < 3) {
  alert( "номер " + i + "!" );
  i++;
}

////////////////////////////////////////////////////////////////

/*#26*/

var num;

do {
  num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num != null);
/*Цикл do..while повторяется, пока верны две проверки:

Проверка num <= 100 – то есть, введённое число всё еще меньше 100.
Проверка num != null – значение null означает, что посетитель нажал «Отмена», в этом случае цикл тоже нужно прекратить.
Кстати, сравнение num <= 100 при вводе null даст true, так что вторая проверка необходима.*/

////////////////////////////////////////////////////////////////

/*#27*/

/*Схема решения
Для всех i от 1 до 10 {
  проверить, делится ли число i на какое - либо из чисел до него
  если делится, то это i не подходит, берем следующее
  если не делится, то i - простое число
}
Решение
Решение с использованием метки:*/

 nextPrime:
  for (var i = 2; i <= 10; i++) {

    for (var j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
//Конечно же, его можно оптимизировать с точки зрения производительности. Например, проверять все j не от 2 до i, а от 2 до квадратного корня из i. А для очень больших чисел – существуют более эффективные специализированные алгоритмы проверки простоты числа, например квадратичное решето и решето числового поля.

////////////////////////////////////////////////////////////////

/*#28*/

/*Один или ноль
Два*/

////////////////////////////////////////////////////////////////

/*#29*/

//Если совсем точно следовать условию, то сравнение должно быть строгим '==='.

//В реальном случае, скорее всего, подойдёт обычное сравнение '=='.

if(browser == 'IE') {
  alert('О, да у вас IE!');
} else if (browser == 'Chrome'
 || browser == 'Firefox'
 || browser == 'Safari'
 || browser == 'Opera') {
  alert('Да, и эти браузеры мы поддерживаем');
} else {
  alert('Мы надеемся, что и в вашем браузере все ок!');
}
//Обратите внимание: конструкция browser == 'Chrome' || browser == 'Firefox' ... разбита на несколько строк для лучшей читаемости.

//Но всё равно запись через switch нагляднее.

////////////////////////////////////////////////////////////////

/*#30*/

//Первые две проверки – обычный case, третья разделена на два case:

var a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
//Обратите внимание: break внизу не обязателен, но ставится по «правилам хорошего тона».

//Допустим, он не стоит. Есть шанс, что в будущем нам понадобится добавить в конец ещё один case, например case 4, и мы, вполне вероятно, забудем этот break поставить. В результате выполнение case 2/case 3 продолжится на case 4 и будет ошибка.

////////////////////////////////////////////////////////////////

/*#31*/

//Оба варианта функции работают одинаково, отличий нет.

////////////////////////////////////////////////////////////////

/*#32*/

//Используя оператор '?':

function checkAge(age) {
  return (age > 18) ? true : confirm('Родители разрешили?');
}
//Используя оператор || (самый короткий вариант):

function checkAge(age) {
  return (age > 18) || confirm('Родители разрешили?');
}

////////////////////////////////////////////////////////////////

/*#33*/

//Вариант решения с использованием if:

function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
//Вариант решения с оператором '?':

function min(a, b) {
  return a < b ? a : b;
}
//P.S. Случай равенства a == b здесь отдельно не рассматривается, так как при этом неважно, что возвращать.

////////////////////////////////////////////////////////////////

/*#34*/

/**
 * Возводит x в степень n (комментарий JSDoc)
 *
 * @param {number} x число, которое возводится в степень
 * @param {number} n степень, должна быть целым числом больше 1
 *
 * @return {number} x в степени n
 */
function pow(x, n) {
  var result = x;

  for (var i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

var x = prompt("x?", '');
var n = prompt("n?", '');

if (n <= 1) {
  alert('Степень ' + n +
    'не поддерживается, введите целую степень, большую 1'
  );
} else {
  alert( pow(x, n) );
}

////////////////////////////////////////////////////////////////

/*#35*/

//Решение с использованием цикла:

 function sumTo(n) {
  var sum = 0;
  for (var i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
//Решение через рекурсию:

 function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
//Решение по формуле: sumTo(n) = n*(n+1)/2:

 function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
//P.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.

//Вариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов.

//Рекурсия в данном случае работает медленнее всех.

//P.P.S. Существует ограничение глубины вложенных вызовов, поэтому рекурсивный вызов sumTo(100000) выдаст ошибку.

////////////////////////////////////////////////////////////////

/*#36*/

//По свойствам факториала, как описано в условии, n! можно записать как n * (n-1)!.

//То есть, результат функции для n можно получить как n, умноженное на результат функции для n-1, и так далее до 1!:

 function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
//Базисом рекурсии является значение 1. А можно было бы сделать базисом и 0. Тогда код станет чуть короче:

 function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
//В этом случае вызов factorial(1) сведётся к 1*factorial(0), будет дополнительный шаг рекурсии.

////////////////////////////////////////////////////////////////

/*#37*/

/*Вычисление рекурсией (медленное)
Решение по формуле, используя рекурсию:*/

 function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // не запускаем, подвесит браузер
/*При больших значениях n оно будет работать очень медленно. Например, fib(77) уже будет вычисляться очень долго.

Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз. Например, посмотрим на отрывок вычислений:

...*/
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
//...
/*Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено два раза, совершенно независимо.

Можно это оптимизировать, запоминая уже вычисленные значения, получится гораздо быстрее. Альтернативный вариант – вообще отказаться от рекурсии, а вместо этого в цикле начать с первых значений 1, 2, затем из них получить fib(3), далее fib(4), затем fib(5) и так далее, до нужного значения.

Это решение будет наиболее эффективным. Попробуйте его написать.

Алгоритм вычисления в цикле
Будем идти по формуле слева-направо:
*/
var a = 1, b = 1; // начальные значения
var c = a + b; // 2

/* переменные на начальном шаге:
a  b  c
1, 1, 2
*/
//Теперь следующий шаг, присвоим a и b текущие 2 числа и получим новое следующее в c:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
   a  b  c
1, 1, 2, 3
*/
//Следующий шаг даст нам ещё одно число последовательности:

a = b, b = c;
c = a + b;

/* стало так (ещё число):
      a  b  c
1, 1, 2, 3, 5
*/
//Повторять в цикле до тех пор, пока не получим нужное значение. Это гораздо быстрее, чем рекурсия, хотя бы потому что ни одно из чисел не вычисляется дважды.

//P.S. Этот подход к вычислению называется динамическое программирование снизу-вверх.

//Код для вычисления в цикле
 function fib(n) {
  var a = 1,
    b = 1;
  for (var i = 3; i <= n; i++) {
    var c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
//Цикл здесь начинается с i=3, так как первое и второе числа Фибоначчи заранее записаны в переменные a=1, b=1.

////////////////////////////////////////////////////////////////

/*#38*/

//Первый код выведет function ..., второй – ошибку во всех браузерах, кроме IE8-.

 // обычное объявление функции (Function Declaration)
function g() { return 1; };

alert(g); // функция
//Во втором коде скобки есть, значит функция внутри является не Function Declaration, а частью выражения, то есть Named Function Expression. Его имя видно только внутри, снаружи переменная g не определена.

 // Named Function Expression!
(function g() { return 1; });

alert(g);  // Ошибка!
//Все браузеры, кроме IE8-, поддерживают это ограничение видимости и выведут ошибку, "undefined variable".

////////////////////////////////////////////////////////////////

/*#39*/

function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  var result = 1;
  for (var i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}

////////////////////////////////////////////////////////////////

/*#40*/

//Новый тест может быть, к примеру, таким:

it("любое число в степени 0 равно 1", function() {
  assert.equal(pow(123, 0), 1);
});
/*Конечно, желательно проверить на нескольких числах.

Поэтому лучше будет создать блок describe, аналогичный тому, что мы делали для произвольных чисел:*/

describe("любое число, кроме нуля, в степени 0 равно 1", function() {

  function makeTest(x) {
    it("при возведении " + x + " в степень 0 результат: 1", function() {
      assert.equal(pow(x, 0), 1);
    });
  }

  for (var x = -5; x <= 5; x += 2) {
    makeTest(x);
  }

});
/*И не забудем добавить отдельный тест для нуля:

...*/
it("ноль в нулевой степени даёт NaN", function() {
  assert( isNaN(pow(0, 0)), "0 в степени 0 не NaN");
});
//...

////////////////////////////////////////////////////////////////

/*#41*/

/*Этот тест демонстрирует один из соблазнов, которые ожидают начинающего автора тестов.

Вместо того, чтобы написать три различных теста, он изложил их в виде одного потока вычислений, с несколькими assert.

Иногда так написать легче и проще, однако при ошибке в тесте гораздо менее очевидно, что же пошло не так.

Если в сложном тесте произошла ошибка где-то посередине потока вычислений, то придётся выяснять, какие конкретно были входные и выходные данные на этот момент, то есть по сути – отлаживать код самого теста.

Гораздо лучше будет разбить тест на несколько блоков it, с чётко прописанными входными и выходными данными.*/

describe("Возводит x в степень n", function() {
  it("5 в степени 1 равно 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 в степени 2 равно 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 в степени 3 равно 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
//Можно использовать цикл для генерации блоков it, в этом случае важно, чтобы сам код такого цикла был достаточно простым. Иногда проще записать несколько блоков it вручную, как сделано выше, чем «городить огород» из синтаксических конструкций.

////////////////////////////////////////////////////////////////

/*#42*/

//Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности… А впрочем, посмотрим сами:

 alert( 6.35.toFixed(20) ); // 6.34999999999999964473
//Интерпретатор видит число как 6.34..., поэтому и округляет вниз.

////////////////////////////////////////////////////////////////

/*#43*/

//Есть два основных подхода.

//Можно хранить сами цены в «копейках» (центах и т.п.). Тогда они всегда будут целые и проблема исчезнет. Но при показе и при обмене данными нужно будет это учитывать и не забывать делить на 100.

//При операциях, когда необходимо получить окончательный результат – округлять до 2-го знака после запятой. Все, что дальше – ошибка округления:

 var price1 = 0.1, price2 = 0.2;
alert( +(price1 + price2).toFixed(2) );

////////////////////////////////////////////////////////////////

/*#44*/

//Потому что i никогда не станет равным 10.

//Запустите, чтобы увидеть реальные значения i:

 var i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) alert( i );
}
//Ни одно из них в точности не равно 10.

////////////////////////////////////////////////////////////////

/*#45*/

function fibBinet(n) {
  var phi = (1 + Math.sqrt(5)) / 2;
  // используем Math.round для округления до ближайшего целого
  return Math.round(Math.pow(phi, n) / Math.sqrt(5));
}

function fib(n) {
  var a = 1,
    b = 0,
    x;
  for (i = 0; i < n; i++) {
    x = a + b;
    a = b
    b = x;
  }
  return b;
}

alert( fibBinet(2) ); // 1, равно fib(2)
alert( fibBinet(8) ); // 21, равно fib(8)
alert( fibBinet(77) ); // 5527939700884755
alert( fib(77) ); // 5527939700884757, не совпадает!

/*Результат вычисления F77 получился неверным!

Причина – в ошибках округления, ведь √5 – бесконечная дробь.

Ошибки округления при вычислениях множатся и, в итоге, дают расхождение.*/

////////////////////////////////////////////////////////////////

/*#46*/

//Сгенерируем значение в диапазоне 0..1 и умножим на max:

 var max = 10;

alert( Math.random() * max );

////////////////////////////////////////////////////////////////

/*#47*/

/*Очевидное неверное решение (round)
Самый простой, но неверный способ – это сгенерировать значение в интервале min..max и округлить его Math.round, вот так:
*/
 function randomInteger(min, max) {
  var rand = min + Math.random() * (max - min)
  rand = Math.round(rand);
  return rand;
}

alert( randomInteger(1, 3) );
/*Эта функция работает. Но при этом она некорректна: вероятность получить крайние значения min и max будет в два раза меньше, чем любые другие.

При многократном запуске этого кода вы легко заметите, что 2 выпадает чаще всех.

Это происходит из-за того, что Math.round() получает разнообразные случайные числа из интервала от 1 до 3, но при округлении до ближайшего целого получится, что:

значения из диапазона 1   ... 1.49999..  станут 1
значения из диапазона 1.5 ... 2.49999..  станут 2
значения из диапазона 2.5 ... 2.99999..  станут 3
Отсюда явно видно, что в 1 (как и 3) попадает диапазон значений в два раза меньший, чем в 2. Из-за этого такой перекос.

Верное решение с round
Правильный способ: Math.round(случайное от min-0.5 до max+0.5)*/

function randomInteger(min, max) {
    var rand = min - 0.5 + Math.random() * (max - min + 1)
    rand = Math.round(rand);
    return rand;
  }

alert( randomInteger(5, 10) );
/*В этом случае диапазон будет тот же (max-min+1), но учтена механика округления round.

Решение с floor
Альтернативный путь – применить округление Math.floor() к случайному числу от min до max+1.

Например, для генерации целого числа от 1 до 3, создадим вспомогательное случайное значение от 1 до 4 (не включая 4).

Тогда Math.floor() округлит их так:

1 ... 1.999+ станет 1
2 ... 2.999+ станет 2
3 ... 3.999+ станет 3
Все диапазоны одинаковы. Итак, код:*/

function randomInteger(min, max) {
    var rand = min + Math.random() * (max + 1 - min);
    rand = Math.floor(rand);
    return rand;
  }

alert( randomInteger(5, 10) );

////////////////////////////////////////////////////////////////

/*#48*/

/*Мы не можем просто заменить первый символ, т.к. строки в JavaScript неизменяемы.

Но можно пересоздать строку на основе существующей, с заглавным первым символом:*/

var newStr = str[0].toUpperCase() + str.slice(1);
/*Однако, есть небольшая проблемка – в случае, когда строка пуста, будет ошибка.

Ведь str[0] == undefined, а у undefined нет метода toUpperCase().

Выхода два. Первый – использовать str.charAt(0), он всегда возвращает строку, для пустой строки – пустую, но не undefined. Второй – отдельно проверить на пустую строку, вот так:*/

 function ucFirst(str) {
  // только пустая строка в логическом контексте даст false
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("вася") );
//P.S. Возможны и более короткие решения, использующие методы для работы со строками, которые мы пройдём далее.

////////////////////////////////////////////////////////////////

/*#49*/

/*Метод indexOf ищет совпадение с учетом регистра. То есть, в строке 'xXx' он не найдет 'XXX'.

Для проверки, сначала приведем строку str к нижнему регистру, а затем уже будем искать.*/

 function checkSpam(str) {
  var lowerStr = str.toLowerCase();

  return !!(~lowerStr.indexOf('viagra') || ~lowerStr.indexOf('xxx'));
}

alert( checkSpam('buy ViAgRA now') );
alert( checkSpam('free xxxxx') );
alert( checkSpam("innocent rabbit") );

////////////////////////////////////////////////////////////////

/*#50*/

//Так как окончательная длина строки должна быть maxlength, то нужно её обрезать немного короче, чтобы дать место для троеточия.

 function truncate(str, maxlength) {
  if (str.length > maxlength) {
    return str.slice(0, maxlength - 3) + '...';
    // итоговая длина равна maxlength
  }

  return str;
}

alert( truncate("Вот, что мне хотелось бы сказать на эту тему:", 20) );
alert( truncate("Всем привет!", 20) );
//Можно было бы написать этот код ещё короче:

 function truncate(str, maxlength) {
  return (str.length > maxlength) ?
    str.slice(0, maxlength - 3) + '...' : str;
}

////////////////////////////////////////////////////////////////

/*#51*/

//Возьмём часть строки после первого символа и приведём к числу: +str.slice(1).

////////////////////////////////////////////////////////////////

/*#52*/

function isEmpty(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

var schedule = {};

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "подъём";

alert( isEmpty(schedule) ); // false

////////////////////////////////////////////////////////////////

/*#53*/

"use strict";

var salaries = {
  "Вася": 100,
  "Петя": 300,
  "Даша": 250
};

var sum = 0;
for (var name in salaries) {
  sum += salaries[name];
}

alert( sum );

////////////////////////////////////////////////////////////////

/*#54*/

"use strict";

var salaries = {
  "Вася": 100,
  "Петя": 300,
  "Даша": 250
};

var max = 0;
var maxName = "";
for (var name in salaries) {
  if (max < salaries[name]) {
    max = salaries[name];
    maxName = name;
  }
}

alert( maxName || "нет сотрудников" );

////////////////////////////////////////////////////////////////

/*#55*/

var menu = {
  width: 200,
  height: 300,
  title: "My menu"
};

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function multiplyNumeric(obj) {
  for (var key in obj) {
    if (isNumeric(obj[key])) {
      obj[key] *= 2;
    }
  }
}

multiplyNumeric(menu);

alert( "menu width=" + menu.width + " height=" + menu.height + " title=" + menu.title );

////////////////////////////////////////////////////////////////

/*#56*/

/*
Последний элемент имеет индекс на 1 меньший, чем длина массива.

Например:
*/
var fruits = ["Яблоко", "Груша", "Слива"];
//Длина этого массива fruits.length равна 3. Здесь «Яблоко» имеет индекс 0, «Груша» – индекс 1, «Слива» – индекс 2.

//То есть, для массива длины goods:

var lastItem = goods[goods.length - 1]; // получить последний элемент

////////////////////////////////////////////////////////////////

/*#57*/

//Текущий последний элемент имеет индекс goods.length-1. Значит, индексом нового элемента будет goods.length:

goods[goods.length] = 'Компьютер'

////////////////////////////////////////////////////////////////

/*#58*/

var styles = ["Джаз", "Блюз"];
styles.push("Рок-н-Ролл");
styles[styles.length - 2] = "Классика";
alert( styles.shift() );
styles.unshift("Рэп", "Регги");

////////////////////////////////////////////////////////////////

/*#59*/

//Для вывода нужен случайный номер от 0 до arr.length-1 включительно.

 var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];

var rand = Math.floor(Math.random() * arr.length);

alert( arr[rand] );

////////////////////////////////////////////////////////////////

/*#60*/

//В решение ниже обратите внимание: мы не приводим value к числу сразу после prompt, так как если сделать value = +value, то после этого отличить пустую строку от нуля уже никак нельзя. А нам здесь нужно при пустой строке прекращать ввод, а при нуле – продолжать.

 var numbers = [];

while (true) {

  var value = prompt("Введите число", 0);

  if (value === "" || value === null || isNaN(value)) break;

  numbers.push(+value);
}

var sum = 0;
for (var i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}

alert( sum );

////////////////////////////////////////////////////////////////

/*#61*/

var arr = [1, 2, 3];

var arr2 = arr; // (*)
arr2[0] = 5;

alert( arr[0] );
alert( arr2[0] );
/*Код выведет 5 в обоих случаях, так как массив является объектом. В строке (*) в переменную arr2 копируется ссылка на него, а сам объект в памяти по-прежнему один, в нём отражаются изменения, внесенные через arr2 или arr.

В частности, сравнение arr2 == arr даст true.

Если нужно именно скопировать массив, то это можно сделать, например, так:*/

var arr2 = [];
for (var i = 0; i < arr.length; i++) arr2[i] = arr[i];

////////////////////////////////////////////////////////////////

/*#62*/

//Возможное решение:

function find(array, value) {

  for (var i = 0; i < array.length; i++) {
    if (array[i] == value) return i;
  }

  return -1;
}
//Однако, в нем ошибка, т.к. сравнение == не различает 0 и false.

//Поэтому лучше использовать ===. Кроме того, в современном стандарте JavaScript существует встроенная функция Array#indexOf, которая работает именно таким образом. Имеет смысл ей воспользоваться, если браузер ее поддерживает.

 function find(array, value) {
  if (array.indexOf) { // если метод существует
    return array.indexOf(value);
  }

  for (var i = 0; i < array.length; i++) {
    if (array[i] === value) return i;
  }

  return -1;
}

var arr = ["a", -1, 2, "b"];

var index = find(arr, 2);

alert( index );
//… Но еще лучшим вариантом было бы определить find по-разному в зависимости от поддержки браузером метода indexOf:

// создаем пустой массив и проверяем поддерживается ли indexOf
if ([].indexOf) {

  var find = function(array, value) {
    return array.indexOf(value);
  }

} else {
  var find = function(array, value) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === value) return i;
    }

    return -1;
  }

}
//Этот способ – лучше всего, т.к. не требует при каждом запуске find проверять поддержку indexOf.

////////////////////////////////////////////////////////////////

/*#63*/

/*Алгоритм решения
Создайте временный пустой массив var results = [].
Пройдите по элементам arr в цикле и заполните его.
Возвратите results.
Решение*/
 function filterRange(arr, a, b) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] >= a && arr[i] <= b) {
      result.push(arr[i]);
    }
  }

  return result;
}

var arr = [5, 4, 3, 8, 0];

var filtered = filterRange(arr, 3, 5);
alert( filtered );

////////////////////////////////////////////////////////////////

/*#64*/

//Их сумма равна 1060.

 // шаг 1
var arr = [];

for (var i = 2; i < 100; i++) {
  arr[i] = true
}

// шаг 2
var p = 2;

do {
  // шаг 3
  for (i = 2 * p; i < 100; i += p) {
    arr[i] = false;
  }

  // шаг 4
  for (i = p + 1; i < 100; i++) {
    if (arr[i]) break;
  }

  p = i;
} while (p * p < 100); // шаг 5

// шаг 6 (готово)
// посчитать сумму
var sum = 0;
for (i = 0; i < arr.length; i++) {
  if (arr[i]) {
    sum += i;
  }
}

alert( sum );

////////////////////////////////////////////////////////////////

/*#65*/

//Подсказка (медленное решение)
/*Можно просто посчитать для каждого элемента массива все суммы, которые с него начинаются.

Например, для [-1, 2, 3, -9, 11]:

// Начиная с -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Начиная с 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Начиная с 3:
3
3 + (-9)
3 + (-9) + 11

// Начиная с -9
-9
-9 + 11

// Начиная с 11
11
Сделайте вложенный цикл, который на внешнем уровне бегает по элементам массива, а на внутреннем – формирует все суммы элементов, которые начинаются с текущей позиции.

Медленное решение
Решение через вложенный цикл:*/

 function getMaxSubSum(arr) {
  var maxSum = 0; // если совсем не брать элементов, то сумма 0

  for (var i = 0; i < arr.length; i++) {
    var sumFixedStart = 0;
    for (var j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
/*Такое решение имеет оценку сложности O(n2), то есть при увеличении массива в 2 раза алгоритм требует в 4 раза больше времени. На больших массивах (1000, 10000 и более элементов) такие алгоритмы могут приводить к серьёзным «тормозам».

Подсказка (быстрое решение)
Будем идти по массиву и накапливать в некоторой переменной s текущую частичную сумму. Если в какой-то момент s окажется отрицательной, то мы просто присвоим s=0. Утверждается, что максимум из всех значений переменной s, случившихся за время работы, и будет ответом на задачу.

Докажем этот алгоритм.

В самом деле, рассмотрим первый момент времени, когда сумма s стала отрицательной. Это означает, что, стартовав с нулевой частичной суммы, мы в итоге пришли к отрицательной частичной сумме – значит, и весь этот префикс массива, равно как и любой его суффикс имеют отрицательную сумму.

Следовательно, от всего этого префикса массива в дальнейшем не может быть никакой пользы: он может дать только отрицательную прибавку к ответу.*/


//Быстрое решение
 function getMaxSubSum(arr) {
  var maxSum = 0,
    partialSum = 0;
  for (var i = 0; i < arr.length; i++) {
    partialSum += arr[i];
    maxSum = Math.max(maxSum, partialSum);
    if (partialSum < 0) partialSum = 0;
  }
  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
//Информацию об алгоритме вы также можете прочитать здесь: http://e-maxx.ru/algo/maximum_average_segment и здесь: Maximum subarray problem.

//Этот алгоритм требует ровно одного прохода по массиву, его сложность имеет оценку O(n).

////////////////////////////////////////////////////////////////

/*#66*/

//Решение заключается в превращении obj.className в массив при помощи split. После этого в нем можно проверить наличие класса, и если нет – добавить.

 function addClass(obj, cls) {
  var classes = obj.className ? obj.className.split(' ') : [];

  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == cls) return; // класс уже есть
  }

  classes.push(cls); // добавить

  obj.className = classes.join(' '); // и обновить свойство
}

var obj = {
  className: 'open menu'
};

addClass(obj, 'new');
addClass(obj, 'open');
addClass(obj, 'me');
alert(obj.className) // open menu new me
/*P.S. «Альтернативный» подход к проверке наличия класса вызовом obj.className.indexOf(cls) был бы неверным. В частности, он найдёт cls = "menu" в строке классов obj.className = "open mymenu".

P.P.S. Проверьте, нет ли в вашем решении присвоения obj.className += " " + cls. Не добавляет ли оно лишний пробел в случае, если изначально obj.className = ""?*/

////////////////////////////////////////////////////////////////

/*#67*/

/*Идея
Задача может быть решена несколькими способами. Один из них – разбить строку по дефису str.split('-'), затем последовательно сконструировать новую.

Решение
Разобьем строку в массив, а затем преобразуем его элементы и сольём обратно:*/

 function camelize(str) {
  var arr = str.split('-');

  for (var i = 1; i < arr.length; i++) {
    // преобразовать: первый символ с большой буквы
    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
  }

  return arr.join('');
}

alert( camelize("background-color") ); // backgroundColor
alert( camelize("list-style-image") ); // listStyleImage
alert( camelize("-webkit-transition") ); // WebkitTransition

////////////////////////////////////////////////////////////////

/*#68*/

/*Решение заключается в том, чтобы разбить className в массив классов, а затем пройтись по нему циклом. Если класс есть – удаляем его splice, заново объединяем массив в строку и присваиваем объекту.*/

function removeClass(obj, cls) {
  var classes = obj.className.split(' ');

  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == cls) {
      classes.splice(i, 1); // удалить класс
      i--; // (*)
    }
  }
  obj.className = classes.join(' ');

}

var obj = {
  className: 'open menu menu'
}

removeClass(obj, 'blabla');
removeClass(obj, 'menu')
alert(obj.className) // open
/*В примере выше есть тонкий момент. Элементы массива проверяются один за другим. При вызове splice удаляется текущий, i-й элемент, и те элементы, которые идут дальше, сдвигаются на его место.

Таким образом, на месте i оказывается новый, непроверенный элемент.

Чтобы это учесть, строчка (*) уменьшает i, чтобы следующая итерация цикла заново проверила элемент с номером i. Без нее функция будет работать с ошибками.*/

////////////////////////////////////////////////////////////////

/*#69*/

function filterRangeInPlace(arr, a, b) {

  for (var i = 0; i < arr.length; i++) {
    var val = arr[i];
    if (val < a || val > b) {
      arr.splice(i--, 1);
    }
  }

}

var arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4);
alert( arr ); // [3, 1]

////////////////////////////////////////////////////////////////

/*#70*/

var arr = [5, 2, 1, -10, 8];

function compareReversed(a, b) {
  return b - a;
}

arr.sort(compareReversed);

alert( arr );

////////////////////////////////////////////////////////////////

/*#71*/

//Для копирования массива используем slice(), и тут же – сортировку:

var arr = ["HTML", "JavaScript", "CSS"];

var arrSorted = arr.slice().sort();

alert( arrSorted );
alert( arr );

////////////////////////////////////////////////////////////////

/*#72*/

/*Подсказка
Функция сортировки должна возвращать случайный результат сравнения. Используйте для этого Math.random.

Решение
Обычно Math.random() возвращает результат от 0 до 1. Вычтем 0.5, чтобы область значений стала [-0.5 ... 0.5).
*/
var arr = [1, 2, 3, 4, 5];

function compareRandom(a, b) {
  return Math.random() - 0.5;
}

arr.sort(compareRandom);

alert( arr ); // элементы в случайном порядке, например [3,5,1,2,4]

////////////////////////////////////////////////////////////////

/*#73*/

//Для сортировки объявим и передадим в sort функцию, которая сравнивает объекты по полю age:

// Наша функция сравнения
function compareAge(personA, personB) {
  return personA.age - personB.age;
}

// проверка
var vasya = { name: "Вася", age: 23 };
var masha = { name: "Маша", age: 18 };
var vovochka = { name: "Вовочка", age: 6 };

var people = [ vasya , masha , vovochka ];

people.sort(compareAge);

// вывести
for(var i = 0; i < people.length; i++) {
  alert(people[i].name); // Вовочка Маша Вася
}

////////////////////////////////////////////////////////////////

/*#74*/

//Вывод списка в цикле
 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  var tmp = list;

  while (tmp) {
    alert( tmp.value );
    tmp = tmp.next;
  }

}

printList(list);
/*Обратите внимание, что для прохода по списку используется временная переменная tmp, а не list. Можно было бы и бегать по списку, используя входной параметр функции:*/



            function printList(list) {

  while(list) {
    alert( list.value );
    list = list.next;
  }

}
/*…Но при этом мы в будущем не сможем расширить функцию и сделать со списком что-то ещё, ведь после окончания цикла начало списка уже нигде не хранится.

Поэтому и используется временная переменная – чтобы сделать код расширяемым, и, кстати, более понятным, ведь роль tmp – исключительно обход списка, как i в цикле for.

Вывод списка с рекурсией
Рекурсивный вариант printList(list) следует простой логике: вывести текущее значение (1), а затем пропустить через себя следующее (2):*/

 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert( list.value ); // (1)

  if (list.next) {
    printList(list.next); // (2)
  }

}

printList(list);
/*Обратный вывод с рекурсией
Обратный вывод – почти то же самое, что прямой, просто сначала мы обрабатываем следующее значение, а потом – текущее:*/

 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert( list.value );
}

printReverseList(list);
Обратный вывод без рекурсии
 var list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  var arr = [];
  var tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (var i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
/*Обратный вывод без рекурсии быстрее.

По сути, рекурсивный вариант и нерекурсивный работают одинаково: они проходят список и запоминают его элементы, а потом выводят в обратном порядке.

В случае с массивом это очевидно, а для рекурсии запоминание происходит в стеке (внутренней специальной структуре данных): когда вызывается вложенная функция, то интерпретатор сохраняет в стек текущие параметры. Вложенные вызовы заполняют стек, а потом он выводится в обратном порядке.

При этом, при рекурсии в стеке сохраняется не только элемент списка, а другая вспомогательная информация, необходимая для возвращения из вложенного вызова. Поэтому тратится больше памяти. Все эти расходы отсутствуют в варианте без рекурсии, так как в массиве хранится именно то, что нужно.

Преимущество рекурсии, с другой стороны – более короткий и, зачастую, более простой код.

////////////////////////////////////////////////////////////////

/*#75*/

/*Чтобы обнаружить анаграммы, разобьём каждое слово на буквы и отсортируем их. В отсортированном по буквам виде все анаграммы одинаковы.

Например:

воз, зов -> взо
киборг, гробик -> бгикор
...
По такой последовательности будем делать массив уникальным.

Для этого воспользуемся вспомогательным объектом, в который будем записывать слова по отсортированному ключу:*/

function aclean(arr) {
  // этот объект будем использовать для уникальности
  var obj = {};

  for (var i = 0; i < arr.length; i++) {
    // разбить строку на буквы, отсортировать и слить обратно
    var sorted = arr[i].toLowerCase().split('').sort().join(''); // (*)

    obj[sorted] = arr[i]; // сохраняет только одно значение с таким ключом
  }

  var result = [];

  // теперь в obj находится для каждого ключа ровно одно значение
  for (var key in obj) result.push(obj[key]);

  return result;
}

var arr = ["воз", "киборг", "корсет", "ЗОВ", "гробик", "костер", "сектор"];

alert( aclean(arr) );
/*Приведение слова к сортированному по буквам виду осуществляется цепочкой вызовов в строке (*).

Для удобства комментирования разобьём её на несколько строк (JavaScript это позволяет):*/

var sorted = arr[i] // ЗОВ
  .toLowerCase() // зов
  .split('') // ['з','о','в']
  .sort() // ['в','з','о']
  .join(''); // взо
/*Получится, что два разных слова 'ЗОВ' и 'воз' получат одинаковую отсортированную форму 'взо'.

Следующая строка:

obj[sorted] = arr[i];
В объект obj будет записано сначала первое из слов obj['взо'] = "воз", а затем obj['взо'] = 'ЗОВ'.

Обратите внимание, ключ – отсортирован, а само слово – в исходной форме, чтобы можно было потом получить его из объекта.

Вторая запись по тому же ключу перезапишет первую, то есть в объекте останется ровно одно слово с таким набором букв.*/

////////////////////////////////////////////////////////////////

/*#76*/

/*Решение перебором (медленное)
Пройдём по массиву вложенным циклом.

Для каждого элемента мы будем искать, был ли такой уже. Если был – игнорировать:*/

 function unique(arr) {
  var result = [];

  nextInput:
    for (var i = 0; i < arr.length; i++) {
      var str = arr[i]; // для каждого элемента
      for (var j = 0; j < result.length; j++) { // ищем, был ли он уже?
        if (result[j] == str) continue nextInput; // если да, то следующий
      }
      result.push(str);
    }

  return result;
}

var strings = ["кришна", "кришна", "харе", "харе",
  "харе", "харе", "кришна", "кришна", "8-()"
];

alert( unique(strings) ); // кришна, харе, 8-()
/*Давайте посмотрим, насколько быстро он будет работать.

Предположим, в массиве 100 элементов. Если все они одинаковые, то result будет состоять из одного элемента и вложенный цикл будет выполняться сразу. В этом случае всё хорошо.

А если все, или почти все элементы разные?

В этом случае для каждого элемента понадобится обойти весь текущий массив результатов, после чего – добавить в этот массив.

Для первого элемента – это обойдётся в 0 операций доступа к элементам result (он пока пустой).
Для второго элемента – это обойдётся в 1 операцию доступа к элементам result.
Для третьего элемента – это обойдётся в 2 операции доступа к элементам result.
…Для n-го элемента – это обойдётся в n-1 операций доступа к элементам result.
Всего 0 + 1 + 2 + … + n-1 = (n-1)*n/2 = n2/2 – n/2 (как сумма арифметической прогрессии), то есть количество операций растёт примерно как квадрат от n.

Это очень быстрый рост. Для 100 элементов – 4950 операций, для 1000 – 499500 (по формуле выше).

Поэтому такое решение подойдёт только для небольших массивов. Вместо вложенного for можно использовать и arr.indexOf, ситуация от этого не поменяется, так как indexOf тоже ищет перебором.

Решение с объектом (быстрое)
Наилучшая техника для выбора уникальных строк – использование вспомогательного объекта obj. Ведь название свойства в объекте, с одной стороны – строка, а с другой – всегда уникально. Повторная запись в свойство с тем же именем перезапишет его.

Например, если "харе" попало в объект один раз (obj["харе"] = true), то второе такое же присваивание ничего не изменит.

Решение ниже создаёт объект obj = {} и записывает в него все строки как имена свойств. А затем собирает свойства из объекта в массив через Object.keys(). Дубликатов уже не будет.*/

function unique(arr) {
  var obj = {};

  for (var i = 0; i < arr.length; i++) {
    var str = arr[i];
    obj[str] = true; // запомнить строку в виде свойства объекта
  }

  return Object.keys(obj); // или собрать ключи перебором для IE8-
}

var strings = ["кришна", "кришна", "харе", "харе",
  "харе", "харе", "кришна", "кришна", "8-()"
];

alert( unique(strings) ); // кришна, харе, 8-()
/*Так что можно положить все значения как ключи в объект, а потом достать.*/